<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>PaperWings Blog • Posts by &#34;code&#34; tag</title>
        <link>https://paperwings2019.github.io</link>
        <description></description>
        <language>zh</language>
        <pubDate>Sun, 15 Oct 2023 13:50:21 +0800</pubDate>
        <lastBuildDate>Sun, 15 Oct 2023 13:50:21 +0800</lastBuildDate>
        <category>Code</category>
        <category>Daily</category>
        <item>
            <guid isPermalink="true">https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</guid>
            <title>LeetcodeWeekly-366-03:执行操作使两个字符串相等</title>
            <link>https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</link>
            <category>Code</category>
            <pubDate>Sun, 15 Oct 2023 13:50:21 +0800</pubDate>
            <description><![CDATA[ &lt;h1 id=&#34;题目描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#题目描述&#34;&gt;#&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给你两个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的二进制字符串  &lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  ，两个字符串的长度都是  &lt;code&gt;n&lt;/code&gt;  ，再给你一个正整数  &lt;code&gt;x&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;你可以对字符串  &lt;code&gt;s1&lt;/code&gt;  执行以下操作 &lt;strong&gt;任意次&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择两个下标  &lt;code&gt;i&lt;/code&gt;  和  &lt;code&gt;j&lt;/code&gt;  ，将  &lt;code&gt;s1[i]&lt;/code&gt;  和  &lt;code&gt;s1[j]&lt;/code&gt;  都反转，操作的代价为  &lt;code&gt;x&lt;/code&gt;  。&lt;/li&gt;
&lt;li&gt;选择满足  &lt;code&gt;i &amp;lt; n - 1&lt;/code&gt;  的下标  &lt;code&gt;i&lt;/code&gt;  ，反转  &lt;code&gt;s1[i]&lt;/code&gt;  和  &lt;code&gt;s1[i + 1]&lt;/code&gt;  ，操作的代价为  &lt;code&gt;1&lt;/code&gt;  。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你返回使字符串  &lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  相等的 &lt;strong&gt;最小&lt;/strong&gt; 操作代价之和，如果无法让二者相等，返回  &lt;code&gt;-1&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ，反转字符的意思是将  &lt;code&gt;0&lt;/code&gt;  变成  &lt;code&gt;1&lt;/code&gt;  ，或者  &lt;code&gt;1&lt;/code&gt;  变成  &lt;code&gt;0&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;1100011000&amp;quot;, s2 = &amp;quot;0101001010&amp;quot;, x = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：我们可以执行以下操作：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 3 执行第二个操作。结果字符串是 s1 = &amp;quot;1101111000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 4 执行第二个操作。结果字符串是 s1 = &amp;quot;1101001000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = &amp;quot;0101001010&amp;quot; = s2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;总代价是 1 + 1 + 2 = 4 。这是最小代价和。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;10110&amp;quot;, s2 = &amp;quot;00011&amp;quot;, x = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：无法使两个字符串相等。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == s1.length == s2.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n, x &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  只包含字符  &lt;code&gt;&#39;0&#39;&lt;/code&gt;  和  &lt;code&gt;&#39;1&#39;&lt;/code&gt;  。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a&#34;&gt;解法思路来自 @灵茶山艾府 大佬&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一on2时间动态规划&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法一on2时间动态规划&#34;&gt;#&lt;/a&gt; 解法一：O (n^2) 时间动态规划&lt;/h2&gt;
&lt;h3 id=&#34;如何直接判断能否使两个字符串相等&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何直接判断能否使两个字符串相等&#34;&gt;#&lt;/a&gt; 如何直接判断能否使两个字符串相等？&lt;/h3&gt;
&lt;p&gt;主要看 s1（或者 s2 也可以）中 **“1” 的数量的奇偶性&lt;strong&gt;是否与 s2（或者 s1）中&lt;/strong&gt; “1” 的数量的奇偶性 ** 相同。原因是，第一种操作与第二种操作都不会改变 “1” 的数量的奇偶性。第一种操作和第二种操作同时翻转两个位置，要么反转一个 1 一个 0（奇偶性不变），要么反转两个 1 或者两个 0（“1” 的数量 + 2 或 - 2，奇偶性仍不变）。因此若 s1 和 s2 中 “1” 的数量不相同，可以直接返回 - 1.&lt;/p&gt;
&lt;h3 id=&#34;dp数组的意义递推公式初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dp数组的意义递推公式初始化&#34;&gt;#&lt;/a&gt; DP 数组的意义，递推公式，初始化&lt;/h3&gt;
&lt;p&gt;三个参数：dp (i, j, preRev)，代表&lt;strong&gt;在处理前 i 个位置后，以及 j 个剩下的免费翻转机会，以及根据 preRev 的真假&lt;/strong&gt;（前一个位置是否选择第二种方法进行翻转）的状态下，最小的花费。这是因为，如果在处理先前的字符串时选择了第一种方法，相当于我们在处理之后的字符串时获得了免费的翻转机会。如果前一个位置选择了第二种操作，那么本位需要当作已经被翻转（即如果本来 s1 [2]==‘1’，但 s1 [1] 使用了第二种操作使得 s1 [1] == s2 [1]，那么 s1 [2] 应该被当做 0 来处理）。&lt;/p&gt;
&lt;p&gt;与一般的使用迭代的方法遍历 dp 数组不同，这里使用递归 + cache 的方法来遍历。假如 (s1 [i] == s2 [i]) == &lt;strong&gt;not preRev&lt;/strong&gt;，那么 dp (i, j, preRev) = dp (i-1, j, False)。 假如不同，首先分别计算第一种操作和第二种操作后的花费，取最小值。即 dp (i, j, preRev) = min ( dp (i-1, j+1, False) + x, dp (i-1, j, True) + 1 )。之后，假如 j 不为 0，继续计算免费翻转后的花费，即 dp (i, j, preRev) = min (dp (i, j, preRev), dp (i-1, j-1, False))，注意此处等号右边的 dp (i, j, preRev) 已经是第一种和第二种操作取最小值后的值。&lt;/p&gt;
&lt;p&gt;递归在 i==0 时停止，这时假如 j 不为 0，或者 preRev 不为假，则返回无穷大，保证该分支不会被选入最终结果。否则，返回 0，即 s1 和 s2 都为空时，不需要操作。在主函数中，直接返回 dp (len (s1), 0, False) 的结果。&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度和空间复杂度分析&#34;&gt;#&lt;/a&gt; 时间复杂度和空间复杂度分析&lt;/h3&gt;
&lt;p&gt;计算思路：状态数 * 单个状态下的计算复杂度。因为 i 和 j 分别可以最多可以取到 len (s1)，preRev 的状态集有限，且计算单个状态的时间复杂度是 O (1) ，则总体的时间复杂度为 O (n&lt;sup&gt;2)。同理，空间复杂度也为 O (n&lt;/sup&gt;2)。&lt;/p&gt;
&lt;h3 id=&#34;python代码实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#python代码实现&#34;&gt;#&lt;/a&gt; Python 代码实现&lt;/h3&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (s1.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt; != s2.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;        @cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;dfs&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;i, j, preRev&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; i == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; inf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; ((s1[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] == s2[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]) == (&lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev)):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;) + x, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;True&lt;/span&gt;) + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(t, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1), &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解法二on时间动态规划&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法二on时间动态规划&#34;&gt;#&lt;/a&gt; 解法二：O (n) 时间动态规划&lt;/h2&gt;
&lt;p&gt;单次遍历 s1，记录下与 s2 每个位置上不同的下标，并存储在一个新数组 p 中。&lt;/p&gt;
&lt;h3 id=&#34;如何直接判断能否使两个字符串相等-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何直接判断能否使两个字符串相等-2&#34;&gt;#&lt;/a&gt; 如何直接判断能否使两个字符串相等？&lt;/h3&gt;
&lt;p&gt;同上，假如 p 的长度为奇数，那么可以直接返回 - 1。&lt;/p&gt;
&lt;h3 id=&#34;动态规划意义及递推公式初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#动态规划意义及递推公式初始化&#34;&gt;#&lt;/a&gt; 动态规划意义及递推公式，初始化&lt;/h3&gt;
&lt;p&gt;设 f (i) 为处理数组 p 前 i 个元素所需要花费的时间&lt;/p&gt;
&lt;p&gt;来看如何处理当前位置为 i 的元素：对于第一种操作，花费可看作是 x/2，即 f (i) = f (i-1) + x/2。对于第二种操作，需要看上一个位置与该位置的 “距离”，连续翻转之间的数，即 f (i) = f (i-2) + p [i-1] - p [i]。&lt;/p&gt;
&lt;p&gt;因此 f (0)=0,f (1)=x/2&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度和空间复杂度分析-2&#34;&gt;#&lt;/a&gt; 时间复杂度和空间复杂度分析&lt;/h3&gt;
&lt;p&gt;对于每个 f (i)，我们只需要知道 f (i-1) 和 f (i-2)，因此我们需要维护两个状态（滚动数组），最后返回其中第一个状态。时间复杂度 O (n)，空间复杂度 O (n)。&lt;/p&gt;
&lt;h3 id=&#34;python代码实现-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#python代码实现-2&#34;&gt;#&lt;/a&gt; Python 代码实现&lt;/h3&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1 == s2: &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        p = [i &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1)) &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1[i] != s2[i]]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(p) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        f0, f1 = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i, j &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; pairwise(p):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            f0, f1 = f1, &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(f1 + x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, f0 + j - i)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;(f1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
 ]]></description>
        </item>
    </channel>
</rss>
