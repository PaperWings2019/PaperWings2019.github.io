<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://paperwings2019.github.io</id>
    <title>PaperWings Blog • Posts by &#34;code&#34; tag</title>
    <link href="https://paperwings2019.github.io" />
    <updated>2023-10-24T03:24:44.000Z</updated>
    <category term="Daily" />
    <category term="Code" />
    <entry>
        <id>https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</id>
        <title>C语言常见面试/笔试问题集合</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
        <content type="html">&lt;h1 id=&#34;概念问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概念问题&#34;&gt;#&lt;/a&gt; 概念问题&lt;/h1&gt;
&lt;h2 id=&#34;static关键字的作用原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#static关键字的作用原理&#34;&gt;#&lt;/a&gt; static 关键字的作用 / 原理&lt;/h2&gt;
&lt;p&gt;被 static 修饰的变量或者函数会被放入静态存储区。根据上下文，static 有不同的作用和意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数体内部声明的 static 修饰的变量将被作为静态局部变量。其作用域或者可见范围仍被限制在函数内，即只在函数运行时才能进行访问，但其初始化将在整个程序刚开始运行时就进行，有且仅有一次。这意味着无论多少次调用该函数，该 static 变量不会重新被初始化，而是会继续保持在上一次的值。其寿命等于程序运行寿命。&lt;/li&gt;
&lt;li&gt;一般被 static 修饰的全局变量仅能在一个模块（文件）内可见，而不能被其他模块访问。全局变量仍然被放入静态区，但是可见范围发生了以上变化。&lt;/li&gt;
&lt;li&gt;被 static 修饰的函数声明表示该函数只在当前模块可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存管理问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#内存管理问题&#34;&gt;#&lt;/a&gt; 内存管理问题&lt;/h2&gt;
&lt;h3 id=&#34;内存分配函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#内存分配函数&#34;&gt;#&lt;/a&gt; 内存分配函数&lt;/h3&gt;
&lt;h4 id=&#34;解释malloc-calloc-realloc的区别和用法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解释malloc-calloc-realloc的区别和用法&#34;&gt;#&lt;/a&gt; 解释 &lt;code&gt;malloc&lt;/code&gt; 、 &lt;code&gt;calloc&lt;/code&gt; 、 &lt;code&gt;realloc&lt;/code&gt;  的区别和用法&lt;/h4&gt;
&lt;p&gt;malloc 用于在&lt;strong&gt;堆&lt;/strong&gt;（heap）上动态分配一个指定大小和类型的内存块，但不会初始化内存中的值&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组,但未初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;calloc 用于在堆上动态分配一个指定大小和类型的内存块，并将内存中的值初始化为 0&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;calloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组，初始化各元素为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;realloc 用于将 malloc 或者 calloc 分配的内存扩大或者缩小&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组,但未初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;realloc&lt;/span&gt;(arr, &lt;span class=&#34;number&#34;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;realloc&lt;/span&gt;(arr, &lt;span class=&#34;number&#34;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，假如 realloc 后无法在原地扩展，则会在堆 heap 中另外寻找一块合适的内存块，并自动释放之前的内存&lt;/p&gt;
&lt;h4 id=&#34;什么是内存泄漏memory-leak和悬挂指针dangling-pointer如何避免内存泄漏和悬挂指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是内存泄漏memory-leak和悬挂指针dangling-pointer如何避免内存泄漏和悬挂指针&#34;&gt;#&lt;/a&gt; 什么是内存泄漏（Memory Leak）和悬挂指针（Dangling Pointer）？如何避免内存泄漏和悬挂指针？&lt;/h4&gt;
&lt;p&gt;内存泄漏指程序员未能成功释放动态分配（如 malloc，calloc，realloc）的内存，导致分配的内存一直被占用造成浪费，从而导致程序运行变慢或崩溃。悬挂指针指当某指针所指的内存被释放后，该指针仍然指向原内存地址，再次访问会出现不可预知的行为，变成悬挂指针。悬挂指针也有可能因为存储了局部变量的地址而造成，如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;* &lt;span class=&#34;title function_&#34;&gt;creatInt&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *x = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *ptr = creatInt(); &lt;span class=&#34;comment&#34;&gt;// ptr存储局部变量的地址，是悬挂指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了避免内存泄漏，应该在分配的内存使用完毕后及时使用 free 函数释放。注意不要重复释放内存，并在释放内存后及时将 NULL 赋值给原指针，避免出现悬挂指针。也可以使用智能指针，程序会自动释放内存。&lt;/p&gt;
&lt;h3 id=&#34;数组和指针&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数组和指针&#34;&gt;#&lt;/a&gt; 数组和指针&lt;/h3&gt;
&lt;h4 id=&#34;指针和数组有什么区别如何将指针和数组相互转换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#指针和数组有什么区别如何将指针和数组相互转换&#34;&gt;#&lt;/a&gt; 指针和数组有什么区别？如何将指针和数组相互转换？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;定义和使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;span class=&#34;comment&#34;&gt;// 数组，需要确定数组的大小，元素的类型，元素的类型必须相同，在内存中以连续地址分布&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *p; &lt;span class=&#34;comment&#34;&gt;// 指针，需要指定指向数据的类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;内存中的表示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组在内存中连续分布，有固定的大小，每个元素占据相应的内存大小&lt;/p&gt;
&lt;p&gt;指针在内存中表示所指向的量的地址，自己本身也有一个地址。在不同的操作系统中存储的地址或者本身的地址都可能不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义的数组名称其实就是一个指针，指向所被分配的内存空间中的首地址。作为函数参数时，两者都是等效的，如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; arr[])&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;无论使用哪一类参数传入，都需要注意数组的上限，注意不能越界，否则会发生意外。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *ptr = arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ptr[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 通过指针ptr访问arr[2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;数组指针类型函数定义问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数组指针类型函数定义问题&#34;&gt;#&lt;/a&gt; 数组，指针，类型，函数定义问题&lt;/h3&gt;
&lt;p&gt;一个大小为 10 的数组，元素为指向整型的指针：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;	*a[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个指向大小为 10，元素为整型的数组的指针：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a)[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个函数指针，函数接受一个整型参数并返回一个整型&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a)(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个大小为 10，元素是指向函数的指针的数组，这个函数接受整型参数并返回一个整型&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;])(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一个指针，指向一个大小为 10 的数组，数组的元素是指向函数的指针，这个函数接受整型指针参数并返回一个整型指针&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*) *(*a)[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;](&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;代码结果问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码结果问题&#34;&gt;#&lt;/a&gt; 代码结果问题&lt;/h1&gt;
</content>
        <category term="Code" />
        <updated>2023-10-24T03:24:44.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/</id>
        <title>Leetcode-2516-每种字符至少取 K 个</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/"/>
        <content type="html">&lt;p&gt;hexo&lt;/p&gt;
&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#题目描述&#34;&gt;#&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给你一个由字符  &lt;code&gt;&#39;a&#39;&lt;/code&gt; 、 &lt;code&gt;&#39;b&#39;&lt;/code&gt; 、 &lt;code&gt;&#39;c&#39;&lt;/code&gt;  组成的字符串  &lt;code&gt;s&lt;/code&gt;  和一个非负整数  &lt;code&gt;k&lt;/code&gt;  。每分钟，你可以选择取走  &lt;code&gt;s&lt;/code&gt;  &lt;strong&gt;最左侧&lt;/strong&gt; 还是 &lt;strong&gt;最右侧&lt;/strong&gt; 的那个字符。&lt;/p&gt;
&lt;p&gt;你必须取走每种字符 &lt;strong&gt;至少&lt;/strong&gt;  &lt;code&gt;k&lt;/code&gt;  个，返回需要的 &lt;strong&gt;最少&lt;/strong&gt; 分钟数；如果无法取到，则返回  &lt;code&gt;-1&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s = &amp;quot;aabaaaacaabc&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从 s 的左侧取三个字符，现在共取到两个字符 &amp;#x27;a&amp;#x27; 、一个字符 &amp;#x27;b&amp;#x27; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从 s 的右侧取五个字符，现在共取到四个字符 &amp;#x27;a&amp;#x27; 、两个字符 &amp;#x27;b&amp;#x27; 和两个字符 &amp;#x27;c&amp;#x27; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;共需要 3 + 5 = 8 分钟。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;可以证明需要的最少分钟数是 8 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s = &amp;quot;a&amp;quot;, k = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：无法取到一个字符 &amp;#x27;b&amp;#x27; 或者 &amp;#x27;c&amp;#x27;，所以返回 -1 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt;  仅由字母  &lt;code&gt;&#39;a&#39;&lt;/code&gt; 、 &lt;code&gt;&#39;b&#39;&lt;/code&gt; 、 &lt;code&gt;&#39;c&#39;&lt;/code&gt;  组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= s.length&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;主打一个逆向思维 + 双指针操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要从两边至少分别取 k 个 a，b，c 的字符，剩下的一个连续字符串所含的各字符一定不超过总数减去 k 个。我们要找最小的花费（分钟数），则要找最长的这个连续字符串，且该字符串需要满足上述条件。&lt;/p&gt;
&lt;p&gt;首先对每个字符的数量计数，若有一种字符的出现数量少于 k，那么直接返回 - 1&lt;/p&gt;
&lt;p&gt;然后使用双指针法，遍历左指针的位置，使用右指针去扩大连续字符串的范围，直到满足条件。在左指针向右移动的过程中，&lt;strong&gt;右指针始终递增&lt;/strong&gt;，因此可以做到 O (n) 的时间复杂度，而不是 O (n^2) 去遍历两个指针的位置。&lt;strong&gt;注意特殊情况，即当右指针一步也没走出去，以及 right 当前所指位置并未计入有效字符串中。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度与空间复杂度&#34;&gt;#&lt;/a&gt; 时间复杂度与空间复杂度&lt;/h1&gt;
&lt;p&gt;时间复杂度：一次遍历，复杂度 O (n)&lt;/p&gt;
&lt;p&gt;空间复杂度：双指针占用常数级空间，即 O (1)&lt;/p&gt;
&lt;h1 id=&#34;代码实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码实现&#34;&gt;#&lt;/a&gt; 代码实现&lt;/h1&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;takeCharacters&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, k: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = &amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;b&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;c&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; ch &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; s:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           c[ch] += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; e &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; c:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; c[e] &amp;lt; k:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;# print(c)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        d = &amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;b&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;c&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        right = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        res = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; left &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s)):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;# print(d)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; right &amp;lt; left: &lt;span class=&#34;comment&#34;&gt;#若right甚至未踏出一步，从新的left开始&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                right = left&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; right &amp;lt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s) &lt;span class=&#34;keyword&#34;&gt;and&lt;/span&gt; d[s[right]] &amp;lt; c[s[right]] - k:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                d[s[right]] += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                right += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            res = &lt;span class=&#34;built_in&#34;&gt;max&lt;/span&gt;(res, right - left)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; left &amp;lt; right: &lt;span class=&#34;comment&#34;&gt;# 如果right踏出至少一步，因为left即将左移，那么从字典中减去left所指位置字符的出现数量一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                d[s[left]] -= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s) - res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
        <category term="Code" />
        <updated>2023-10-18T15:31:57.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/</id>
        <title>LeetcodeWeekly-366-04:对数组执行操作使平方和最大</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
        <content type="html">&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#题目描述&#34;&gt;#&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的整数数组  &lt;code&gt;nums&lt;/code&gt;  和一个 &lt;strong&gt;正&lt;/strong&gt; 整数  &lt;code&gt;k&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;你可以对数组执行以下操作 &lt;strong&gt;任意次&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择两个互不相同的下标  &lt;code&gt;i&lt;/code&gt;  和  &lt;code&gt;j&lt;/code&gt;  ，&lt;strong&gt;同时&lt;/strong&gt; 将  &lt;code&gt;nums[i]&lt;/code&gt;  更新为  &lt;code&gt;(nums[i] AND nums[j])&lt;/code&gt;  且将  &lt;code&gt;nums[j]&lt;/code&gt;  更新为  &lt;code&gt;(nums[i] OR nums[j])&lt;/code&gt;  ， &lt;code&gt;OR&lt;/code&gt;  表示按位 &lt;strong&gt;或&lt;/strong&gt; 运算， &lt;code&gt;AND&lt;/code&gt;  表示按位 &lt;strong&gt;与&lt;/strong&gt; 运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你需要从最终的数组里选择  &lt;code&gt;k&lt;/code&gt;  个元素，并计算它们的 &lt;strong&gt;平方&lt;/strong&gt; 之和。&lt;/p&gt;
&lt;p&gt;请你返回你可以得到的 &lt;strong&gt;最大&lt;/strong&gt; 平方和。&lt;/p&gt;
&lt;p&gt;由于答案可能会很大，将答案对  &lt;code&gt;109 + 7&lt;/code&gt;  &lt;strong&gt;取余&lt;/strong&gt; 后返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [2,6,5,8], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：261&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：我们可以对数组执行以下操作：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;261 是可以得到的最大结果。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [4,5,4,7], k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：90&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：不需要执行任何操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;90 是可以得到的最大结果。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a&#34;&gt;解法思路来自 @灵茶山艾府 大佬&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于无论是 AND 还是 OR，都不会改变两个数都是 1 或者 0 的结果，因此&lt;strong&gt;题中操作等价于交换两数的 1 和 0，其中 OR 操作后的数会更大，而 AND 操作后的数会更小，并且增大和减小的值相等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于如果把一个数平均分配给两数的平方和一定小于一个数本身的平方，我们的目的是要将尽可能多的 1 转移到一个数上，并执行 k 次这样的操作。&lt;/p&gt;
&lt;p&gt;先遍历整个 nums，找出每一位上有多少个 1，最多 30 位（10&lt;sup&gt;9 小于 2&lt;/sup&gt;30），存储在 cnt 里。之后遍历 cnt，只要 cnt 每一位上的数还不为 0，就使临时变量 sum 加上 2^i，cnt 对应位减 1，遍历结束后加在最终的 res 里。执行 k 次以上操作，返回 res。&lt;/p&gt;
&lt;h1 id=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度与空间复杂度&#34;&gt;#&lt;/a&gt; 时间复杂度与空间复杂度&lt;/h1&gt;
&lt;p&gt;时间复杂度 O (n)，空间复杂度 O (1)&lt;/p&gt;
&lt;h1 id=&#34;代码实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#代码实现&#34;&gt;#&lt;/a&gt; 代码实现&lt;/h1&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;maxSum&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, nums: &lt;span class=&#34;type&#34;&gt;List&lt;/span&gt;[&lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;], k: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        cnt = [&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; num &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (num != &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                cnt[i] += num % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                i += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                num &amp;gt;&amp;gt;= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        res = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; _ &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(k):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            x = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                t = cnt[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; t:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    x += &lt;span class=&#34;built_in&#34;&gt;pow&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, i)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    cnt[i] = t - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            res += x * x&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; res % (&lt;span class=&#34;built_in&#34;&gt;pow&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;9&lt;/span&gt;) + &lt;span class=&#34;number&#34;&gt;7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
        <category term="Code" />
        <updated>2023-10-17T13:04:07.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</id>
        <title>LeetcodeWeekly-366-03:执行操作使两个字符串相等</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
        <content type="html">&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#题目描述&#34;&gt;#&lt;/a&gt; 题目描述&lt;/h1&gt;
&lt;p&gt;给你两个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的二进制字符串  &lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  ，两个字符串的长度都是  &lt;code&gt;n&lt;/code&gt;  ，再给你一个正整数  &lt;code&gt;x&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;你可以对字符串  &lt;code&gt;s1&lt;/code&gt;  执行以下操作 &lt;strong&gt;任意次&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择两个下标  &lt;code&gt;i&lt;/code&gt;  和  &lt;code&gt;j&lt;/code&gt;  ，将  &lt;code&gt;s1[i]&lt;/code&gt;  和  &lt;code&gt;s1[j]&lt;/code&gt;  都反转，操作的代价为  &lt;code&gt;x&lt;/code&gt;  。&lt;/li&gt;
&lt;li&gt;选择满足  &lt;code&gt;i &amp;lt; n - 1&lt;/code&gt;  的下标  &lt;code&gt;i&lt;/code&gt;  ，反转  &lt;code&gt;s1[i]&lt;/code&gt;  和  &lt;code&gt;s1[i + 1]&lt;/code&gt;  ，操作的代价为  &lt;code&gt;1&lt;/code&gt;  。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你返回使字符串  &lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  相等的 &lt;strong&gt;最小&lt;/strong&gt; 操作代价之和，如果无法让二者相等，返回  &lt;code&gt;-1&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ，反转字符的意思是将  &lt;code&gt;0&lt;/code&gt;  变成  &lt;code&gt;1&lt;/code&gt;  ，或者  &lt;code&gt;1&lt;/code&gt;  变成  &lt;code&gt;0&lt;/code&gt;  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;1100011000&amp;quot;, s2 = &amp;quot;0101001010&amp;quot;, x = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：我们可以执行以下操作：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 3 执行第二个操作。结果字符串是 s1 = &amp;quot;1101111000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 4 执行第二个操作。结果字符串是 s1 = &amp;quot;1101001000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = &amp;quot;0101001010&amp;quot; = s2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;总代价是 1 + 1 + 2 = 4 。这是最小代价和。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;10110&amp;quot;, s2 = &amp;quot;00011&amp;quot;, x = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：无法使两个字符串相等。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == s1.length == s2.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n, x &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1&lt;/code&gt;  和  &lt;code&gt;s2&lt;/code&gt;  只包含字符  &lt;code&gt;&#39;0&#39;&lt;/code&gt;  和  &lt;code&gt;&#39;1&#39;&lt;/code&gt;  。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题思路&#34;&gt;#&lt;/a&gt; 解题思路&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a&#34;&gt;解法思路来自 @灵茶山艾府 大佬&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一on2时间动态规划&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法一on2时间动态规划&#34;&gt;#&lt;/a&gt; 解法一：O (n^2) 时间动态规划&lt;/h2&gt;
&lt;h3 id=&#34;如何直接判断能否使两个字符串相等&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何直接判断能否使两个字符串相等&#34;&gt;#&lt;/a&gt; 如何直接判断能否使两个字符串相等？&lt;/h3&gt;
&lt;p&gt;主要看 s1（或者 s2 也可以）中 **“1” 的数量的奇偶性是否与 s2（或者 s1）中 “1” 的数量的奇偶性 ** 相同。原因是，第一种操作与第二种操作都不会改变 “1” 的数量的奇偶性。第一种操作和第二种操作同时翻转两个位置，要么反转一个 1 一个 0（奇偶性不变），要么反转两个 1 或者两个 0（“1” 的数量 + 2 或 - 2，奇偶性仍不变）。因此若 s1 和 s2 中 “1” 的数量不相同，可以直接返回 - 1.&lt;/p&gt;
&lt;h3 id=&#34;dp数组的意义递推公式初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dp数组的意义递推公式初始化&#34;&gt;#&lt;/a&gt; DP 数组的意义，递推公式，初始化&lt;/h3&gt;
&lt;p&gt;三个参数：dp (i, j, preRev)，代表&lt;strong&gt;在处理前 i 个位置后，以及 j 个剩下的免费翻转机会，以及根据 preRev 的真假&lt;/strong&gt;（前一个位置是否选择第二种方法进行翻转）的状态下，最小的花费。这是因为，如果在处理先前的字符串时选择了第一种方法，相当于我们在处理之后的字符串时获得了免费的翻转机会。如果前一个位置选择了第二种操作，那么本位需要当作已经被翻转（即如果本来 s1 [2]==‘1’，但 s1 [1] 使用了第二种操作使得 s1 [1] == s2 [1]，那么 s1 [2] 应该被当做 0 来处理）。&lt;/p&gt;
&lt;p&gt;与一般的使用迭代的方法遍历 dp 数组不同，这里使用递归 + cache 的方法来遍历。假如 (s1 [i] == s2 [i]) == &lt;strong&gt;not preRev&lt;/strong&gt;，那么 dp (i, j, preRev) = dp (i-1, j, False)。 假如不同，首先分别计算第一种操作和第二种操作后的花费，取最小值。即 dp (i, j, preRev) = min ( dp (i-1, j+1, False) + x, dp (i-1, j, True) + 1 )。之后，假如 j 不为 0，继续计算免费翻转后的花费，即 dp (i, j, preRev) = min (dp (i, j, preRev), dp (i-1, j-1, False))，注意此处等号右边的 dp (i, j, preRev) 已经是第一种和第二种操作取最小值后的值。&lt;/p&gt;
&lt;p&gt;递归在 i==0 时停止，这时假如 j 不为 0，或者 preRev 不为假，则返回无穷大，保证该分支不会被选入最终结果。否则，返回 0，即 s1 和 s2 都为空时，不需要操作。在主函数中，直接返回 dp (len (s1), 0, False) 的结果。&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度和空间复杂度分析&#34;&gt;#&lt;/a&gt; 时间复杂度和空间复杂度分析&lt;/h3&gt;
&lt;p&gt;计算思路：状态数 * 单个状态下的计算复杂度。因为 i 和 j 分别可以最多可以取到 len (s1)，preRev 的状态集有限，且计算单个状态的时间复杂度是 O (1) ，则总体的时间复杂度为 O (n&lt;sup&gt;2)。同理，空间复杂度也为 O (n&lt;/sup&gt;2)。&lt;/p&gt;
&lt;h3 id=&#34;python代码实现&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#python代码实现&#34;&gt;#&lt;/a&gt; Python 代码实现&lt;/h3&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (s1.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt; != s2.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;        @cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;dfs&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;i, j, preRev&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; i == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; inf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; ((s1[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] == s2[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]) == (&lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev)):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;) + x, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;True&lt;/span&gt;) + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(t, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1), &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&#34;解法二on时间动态规划&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解法二on时间动态规划&#34;&gt;#&lt;/a&gt; 解法二：O (n) 时间动态规划&lt;/h2&gt;
&lt;p&gt;单次遍历 s1，记录下与 s2 每个位置上不同的下标，并存储在一个新数组 p 中。&lt;/p&gt;
&lt;h3 id=&#34;如何直接判断能否使两个字符串相等-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何直接判断能否使两个字符串相等-2&#34;&gt;#&lt;/a&gt; 如何直接判断能否使两个字符串相等？&lt;/h3&gt;
&lt;p&gt;两种操作每次都需要正好对两个数操作，则假如 p 的长度为奇数，那么可以直接返回 - 1。&lt;/p&gt;
&lt;h3 id=&#34;动态规划意义及递推公式初始化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#动态规划意义及递推公式初始化&#34;&gt;#&lt;/a&gt; 动态规划意义及递推公式，初始化&lt;/h3&gt;
&lt;p&gt;设 f (i) 为处理数组 p 前 i 个元素所需要花费的时间&lt;/p&gt;
&lt;p&gt;来看如何处理当前位置为 i 的元素：对于第一种操作，花费可看作是 x/2，即 f (i) = f (i-1) + x/2。对于第二种操作，需要看上一个位置与该位置的 “距离”，连续翻转之间的数，即 f (i) = f (i-2) + p [i-1] - p [i]。&lt;/p&gt;
&lt;p&gt;因此 f (0)=0,f (1)=x/2&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#时间复杂度和空间复杂度分析-2&#34;&gt;#&lt;/a&gt; 时间复杂度和空间复杂度分析&lt;/h3&gt;
&lt;p&gt;对于每个 f (i)，我们只需要知道 f (i-1) 和 f (i-2)，因此我们需要维护两个状态（滚动数组），最后返回其中第一个状态。时间复杂度 O (n)，空间复杂度 O (n)。&lt;/p&gt;
&lt;h3 id=&#34;python代码实现-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#python代码实现-2&#34;&gt;#&lt;/a&gt; Python 代码实现&lt;/h3&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1 == s2: &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        p = [i &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1)) &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1[i] != s2[i]]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(p) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        f0, f1 = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i, j &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; pairwise(p):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            f0, f1 = f1, &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(f1 + x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, f0 + j - i)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;(f1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&#34;思考题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#思考题&#34;&gt;#&lt;/a&gt; 思考题&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;如果第一种操作限制 | i-j|&amp;gt;=k 呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以多维护一个整数参数 t，记录下一个可以进行免费翻转的下标位置，即如果使用第一种操作，那么 t 更新为 i+k。在判断是否能免费翻转时，除了 j 还需要看当前 i 是否大于等于 t，如果都满足的话才能免费翻转。&lt;/p&gt;
</content>
        <category term="Code" />
        <updated>2023-10-15T05:50:21.000Z</updated>
    </entry>
</feed>
