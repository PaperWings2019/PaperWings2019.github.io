{
    "version": "https://jsonfeed.org/version/1",
    "title": "PaperWings Blog • All posts by \"code\" tag",
    "description": "",
    "home_page_url": "https://paperwings2019.github.io",
    "items": [
        {
            "id": "https://paperwings2019.github.io/2024/03/09/linux/",
            "url": "https://paperwings2019.github.io/2024/03/09/linux/",
            "title": "linux",
            "date_published": "2024-03-09T12:54:09.000Z",
            "content_html": "<p>hello there</p>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/",
            "url": "https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/",
            "title": "C语言常见面试/笔试问题集合",
            "date_published": "2023-10-24T03:24:44.000Z",
            "content_html": "<h1 id=\"概念问题\"><a class=\"markdownIt-Anchor\" href=\"#概念问题\">#</a> 概念问题</h1>\n<h2 id=\"static关键字的作用原理\"><a class=\"markdownIt-Anchor\" href=\"#static关键字的作用原理\">#</a> static 关键字的作用 / 原理</h2>\n<p>被 static 修饰的变量或者函数会被放入静态存储区。根据上下文，static 有不同的作用和意义</p>\n<ul>\n<li>在函数体内部声明的 static 修饰的变量将被作为静态局部变量。其作用域或者可见范围仍被限制在函数内，即只在函数运行时才能进行访问，但其初始化将在整个程序刚开始运行时就进行，有且仅有一次。这意味着无论多少次调用该函数，该 static 变量不会重新被初始化，而是会继续保持在上一次的值。其寿命等于程序运行寿命。</li>\n<li>一般被 static 修饰的全局变量仅能在一个模块（文件）内可见，而不能被其他模块访问。全局变量仍然被放入静态区，但是可见范围发生了以上变化。</li>\n<li>被 static 修饰的函数声明表示该函数只在当前模块可见。</li>\n</ul>\n<h2 id=\"volatile关键字的作用原理\"><a class=\"markdownIt-Anchor\" href=\"#volatile关键字的作用原理\">#</a> volatile 关键字的作用 / 原理</h2>\n<p>被 volatile 修饰的变量，编译器不会对其进行优化，因为该变量可能会受到意想不到的变化，而读取寄存器内的旧值可能会使程序向意料之外的方向发展。具体场景如下：</p>\n<ul>\n<li>在多任务场景下，某变量可能需要被多个任务所访问，因此可能随时变化。该变量需要被 volatile 修饰，使得编译器不对其进行优化。</li>\n<li>在中断服务场景下，某变量可能被作为中断被触发的标志，而读取旧值会使中断不能及时发生。该变量应该被 volatile 修饰来确保中断能够及时触发。</li>\n<li>在一些硬件寄存器控制场景下，我们可能需要对一些寄存器地址做一些特殊操作。例如我们需要初始化一个硬件，我们需要对其进行循环赋值</li>\n</ul>\n<h2 id=\"内存管理问题\"><a class=\"markdownIt-Anchor\" href=\"#内存管理问题\">#</a> 内存管理问题</h2>\n<h3 id=\"内存分配函数\"><a class=\"markdownIt-Anchor\" href=\"#内存分配函数\">#</a> 内存分配函数</h3>\n<h4 id=\"解释malloc-calloc-realloc的区别和用法\"><a class=\"markdownIt-Anchor\" href=\"#解释malloc-calloc-realloc的区别和用法\">#</a> 解释 <code>malloc</code> 、 <code>calloc</code> 、 <code>realloc</code>  的区别和用法</h4>\n<p>malloc 用于在<strong>堆</strong>（heap）上动态分配一个指定大小和类型的内存块，但不会初始化内存中的值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *arr = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)); <span class=\"comment\">// 分配一个大小为10的整型数组,但未初始化</span></span><br></pre></td></tr></table></figure>\n<p>calloc 用于在堆上动态分配一个指定大小和类型的内存块，并将内存中的值初始化为 0</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *arr = (<span class=\"type\">int</span> *)<span class=\"built_in\">calloc</span>(<span class=\"number\">10</span>, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)); <span class=\"comment\">// 分配一个大小为10的整型数组，初始化各元素为0</span></span><br></pre></td></tr></table></figure>\n<p>realloc 用于将 malloc 或者 calloc 分配的内存扩大或者缩小</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *arr = (<span class=\"type\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">10</span> * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)); <span class=\"comment\">// 分配一个大小为10的整型数组,但未初始化</span></span><br><span class=\"line\"><span class=\"built_in\">realloc</span>(arr, <span class=\"number\">12</span>);</span><br><span class=\"line\"><span class=\"built_in\">realloc</span>(arr, <span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure>\n<p>注意，假如 realloc 后无法在原地扩展，则会在堆 heap 中另外寻找一块合适的内存块，并自动释放之前的内存</p>\n<h4 id=\"什么是内存泄漏memory-leak和悬挂指针dangling-pointer如何避免内存泄漏和悬挂指针\"><a class=\"markdownIt-Anchor\" href=\"#什么是内存泄漏memory-leak和悬挂指针dangling-pointer如何避免内存泄漏和悬挂指针\">#</a> 什么是内存泄漏（Memory Leak）和悬挂指针（Dangling Pointer）？如何避免内存泄漏和悬挂指针？</h4>\n<p>内存泄漏指程序员未能成功释放动态分配（如 malloc，calloc，realloc）的内存，导致分配的内存一直被占用造成浪费，从而导致程序运行变慢或崩溃。悬挂指针指当某指针所指的内存被释放后，该指针仍然指向原内存地址，再次访问会出现不可预知的行为，变成悬挂指针。悬挂指针也有可能因为存储了局部变量的地址而造成，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* <span class=\"title function_\">creatInt</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> *x = (<span class=\"type\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> *ptr = creatInt(); <span class=\"comment\">// ptr存储局部变量的地址，是悬挂指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了避免内存泄漏，应该在分配的内存使用完毕后及时使用 free 函数释放。注意不要重复释放内存，并在释放内存后及时将 NULL 赋值给原指针，避免出现悬挂指针。若在声明指针时未进行初始化，也会出现悬挂指针。也可以使用智能指针，程序会自动释放内存。</p>\n<h4 id=\"什么是内存对齐为什么要内存对齐内存对齐会发生什么\"><a class=\"markdownIt-Anchor\" href=\"#什么是内存对齐为什么要内存对齐内存对齐会发生什么\">#</a> 什么是内存对齐？为什么要内存对齐？内存对齐会发生什么？</h4>\n<p>内存对齐指为了获得更快的运行速度，数据在内存中的存放首地址一般都为 4 的倍数，而不是连续存放。一个简单的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">char</span> c; <span class=\"comment\">// char 占一个byte</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> i; <span class=\"comment\">// int 占四个byte</span></span><br><span class=\"line\">&#125;x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, <span class=\"keyword\">sizeof</span>(x)); <span class=\"comment\">// 输出8,而不是5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这是因为 char 只占一个 byte，而对于 32 位系统来说，地址只能以 4 的倍数去访问。也就说，一个 32 位（4 字节）内存段内，第一个 char 只占据了一个字节，剩下三个字节并不能用于存放 int 的前三个字节，而是只能空出，并在下一个连续的 4 字节段内存放 int。这样以来，struct x 的大小总共就为 8。</p>\n<p>内存对齐的原因是，假如没有该机制，我们可能需要对不同的 4 字节段分别取一部分再组合到一起，而这增加了操作的时间和成本。假如我们遵循内存对齐，那么我们访问数据时就可以直接读取。</p>\n<p>在决定一个结构体的 size 时，需要看各元素之间的大小，有时我们需要垫空白字节，有时不需要。观察以下例子。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//32位系统</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">char</span> c2;  </span><br><span class=\"line\">&#125;x1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">    <span class=\"type\">char</span> c2;  </span><br><span class=\"line\">&#125;x2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> c1;  </span><br><span class=\"line\">    <span class=\"type\">char</span> c2; </span><br><span class=\"line\">    <span class=\"type\">int</span> i;    </span><br><span class=\"line\">&#125;x3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(x1));  <span class=\"comment\">// 输出8 = 4 + ((1 + 1) + 2)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(x2));  <span class=\"comment\">// 输出12 = ((1) + 3) + 4 + ((1) + 3)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,<span class=\"keyword\">sizeof</span>(x3));  <span class=\"comment\">// 输出8 = ((1 + 1) + 2) + 4</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 作者：忆臻</span></span><br><span class=\"line\"><span class=\"comment\">// 链接：https://zhuanlan.zhihu.com/p/30007037</span></span><br><span class=\"line\"><span class=\"comment\">// 来源：知乎</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组和指针\"><a class=\"markdownIt-Anchor\" href=\"#数组和指针\">#</a> 数组和指针</h3>\n<h4 id=\"指针和数组有什么区别如何将指针和数组相互转换\"><a class=\"markdownIt-Anchor\" href=\"#指针和数组有什么区别如何将指针和数组相互转换\">#</a> 指针和数组有什么区别？如何将指针和数组相互转换？</h4>\n<ul>\n<li>定义和使用</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a[<span class=\"number\">5</span>]; <span class=\"comment\">// 数组，需要确定数组的大小，元素的类型，元素的类型必须相同，在内存中以连续地址分布</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p; <span class=\"comment\">// 指针，需要指定指向数据的类型</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>内存中的表示</li>\n</ul>\n<p>数组在内存中连续分布，有固定的大小，每个元素占据相应的内存大小</p>\n<p>指针在内存中表示所指向的量的地址，自己本身也有一个地址。在不同的操作系统中存储的地址或者本身的地址都可能不同。</p>\n<ul>\n<li>相互转换</li>\n</ul>\n<p>定义的数组名称其实就是一个指针，指向所被分配的内存空间中的首地址。作为函数参数时，两者都是等效的，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> arr[])</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span> *arr)</span>;</span><br></pre></td></tr></table></figure>\n<p>无论使用哪一类参数传入，都需要注意数组的上限，注意不能越界，否则会发生意外。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> *ptr = arr;</span><br><span class=\"line\">ptr[<span class=\"number\">2</span>] = <span class=\"number\">10</span>; <span class=\"comment\">// 通过指针ptr访问arr[2]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"数组指针类型函数定义问题\"><a class=\"markdownIt-Anchor\" href=\"#数组指针类型函数定义问题\">#</a> 数组，指针，类型，函数定义问题</h3>\n<p>一个大小为 10 的数组，元素为指向整型的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>\t*a[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>一个指向大小为 10，元素为整型的数组的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> (*a)[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>一个函数指针，函数接受一个整型参数并返回一个整型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> (*a)(<span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n<p>一个大小为 10，元素是指向函数的指针的数组，这个函数接受整型参数并返回一个整型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> (*a[<span class=\"number\">10</span>])(<span class=\"type\">int</span>);</span><br></pre></td></tr></table></figure>\n<p>一个指针，指向一个大小为 10 的数组，数组的元素是指向函数的指针，这个函数接受整型指针参数并返回一个整型指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"type\">int</span>*) *(*a)[<span class=\"number\">10</span>](<span class=\"type\">int</span>*);</span><br></pre></td></tr></table></figure>\n<h2 id=\"进程线程与协程\"><a class=\"markdownIt-Anchor\" href=\"#进程线程与协程\">#</a> 进程，线程与协程</h2>\n<h3 id=\"概念\"><a class=\"markdownIt-Anchor\" href=\"#概念\">#</a> 概念</h3>\n<ul>\n<li>进程：进程是系统资源分配的基本单位，进程之间是相互独立的</li>\n<li>线程：线程属于进程，是系统调度运算的最小单位</li>\n<li>协程：属于轻量级的线程，由程序员手动控制</li>\n</ul>\n<h3 id=\"区别\"><a class=\"markdownIt-Anchor\" href=\"#区别\">#</a> 区别</h3>\n<h4 id=\"进程与线程\"><a class=\"markdownIt-Anchor\" href=\"#进程与线程\">#</a> 进程与线程</h4>\n<ul>\n<li>\n<p>不同单位：进程是系统资源分配的基本单位，而线程是处理器进行运算调度的基本单位。</p>\n</li>\n<li>\n<p>资源分配：进程直接占用系统资源，进程与进程之间占用的资源不同。线程占用一部分所属进程的资源，线程与线程之间可以共享资源。</p>\n</li>\n<li>\n<p>相互切换：进程切换需要保存或者恢复之前的状态，成本较高。线程切换不需要较高的开销，因为它们共享资源。</p>\n</li>\n<li>\n<p>通信方式：进程之间无法直接通信，需要使用 IPC，如管道，消息队列，共享内存等。线程则通过互斥锁，信号量等方式通信。</p>\n</li>\n</ul>\n<h4 id=\"线程与协程\"><a class=\"markdownIt-Anchor\" href=\"#线程与协程\">#</a> 线程与协程</h4>\n<ol>\n<li>一个线程可以有多个协程。</li>\n<li>大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。</li>\n<li>线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li>\n<li>协程并不是取代线程，而且抽象于线程之上。线程是被分割的 CPU 资源，协程是组织好的代码流程，协程需要线程来承载运行。</li>\n</ol>\n<h2 id=\"mysql\"><a class=\"markdownIt-Anchor\" href=\"#mysql\">#</a> MySQL</h2>\n<h3 id=\"acid\"><a class=\"markdownIt-Anchor\" href=\"#acid\">#</a> ACID</h3>\n<p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、<a href=\"https://www.zhihu.com/search?q=%E9%9A%94%E7%A6%BB%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">隔离性</a>（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>\n<ul>\n<li>\n<p><a href=\"https://www.zhihu.com/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">原子性</a>。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。</p>\n</li>\n<li>\n<p>一致性。<a href=\"https://www.zhihu.com/search?q=%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">事务执行</a>的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。</p>\n<p>如果<a href=\"https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">数据库系统</a>运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入<a href=\"https://www.zhihu.com/search?q=%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">物理数据库</a>，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</p>\n</li>\n<li>\n<p>隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>\n</li>\n<li>\n<p>持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</p>\n</li>\n</ul>\n<h3 id=\"四个隔离等级\"><a class=\"markdownIt-Anchor\" href=\"#四个隔离等级\">#</a> 四个隔离等级</h3>\n<p>MySQL 支持四个事务隔离级别，它们分别是：</p>\n<ol>\n<li><strong>读未提交（Read Uncommitted）</strong>：在该隔离级别下，一个事务可以读取到另一个事务未提交的修改。这意味着事务之间没有隔离，可能会出现脏读（Dirty Read）、不可重复读（Non-Repeatable Read）和幻读（Phantom Read）等问题。\n<ul>\n<li>脏读：读取未提交的数据</li>\n<li>不可重复读：同一事务的其他实例可能会在某实例 commit 后有新的 commit，因此不可重复读</li>\n<li>幻读：简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的 “幻影” 行。InnoDB 和 Falcon 存储引擎通过<a href=\"https://www.zhihu.com/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%22422098523%22%7D\">多版本并发控制</a>（MVCC，Multiversion Concurrency Control）机制解决了该问题。</li>\n</ul>\n</li>\n<li><strong>读已提交（Read Committed）</strong>：在该隔离级别下，一个事务只能读取到其他事务已经提交的修改。这样可以避免脏读，但仍然可能发生不可重复读和幻读的问题。</li>\n<li><strong>可重复读（Repeatable Read）</strong>：在该隔离级别下，一个事务在同一个字段上的多次读取结果是一致的，即不可重复读问题得到解决。但是，可能会出现幻读问题，即事务在同一范围内多次查询时，结果集不一致。MVCC 可以解决该问题。</li>\n<li><strong>串行化（Serializable）</strong>：在该隔离级别下，事务是串行执行的，可以避免脏读、不可重复读和幻读等问题。但是，串行化会对系统性能产生较大影响，因为它限制了并发性。</li>\n</ol>\n<p>这些隔离级别可以在使用 SQL 语句中通过设置 <code>SET TRANSACTION ISOLATION LEVEL</code>  来指定。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sqlCopy code</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class=\"line\">SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;</span><br></pre></td></tr></table></figure>\n<p>需要根据具体应用场景和要求选择合适的事务隔离级别，以平衡数据的一致性和性能需求。</p>\n<h1 id=\"代码结果问题\"><a class=\"markdownIt-Anchor\" href=\"#代码结果问题\">#</a> 代码结果问题</h1>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/",
            "url": "https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/",
            "title": "Leetcode-2516-每种字符至少取 K 个",
            "date_published": "2023-10-18T15:31:57.000Z",
            "content_html": "<p>hexo</p>\n<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个由字符  <code>'a'</code> 、 <code>'b'</code> 、 <code>'c'</code>  组成的字符串  <code>s</code>  和一个非负整数  <code>k</code>  。每分钟，你可以选择取走  <code>s</code>  <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>\n<p>你必须取走每种字符 <strong>至少</strong>  <code>k</code>  个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回  <code>-1</code>  。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aabaaaacaabc&quot;, k = 2</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。</span><br><span class=\"line\">从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。</span><br><span class=\"line\">共需要 3 + 5 = 8 分钟。</span><br><span class=\"line\">可以证明需要的最少分钟数是 8 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;, k = 1</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -1 。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 105</code></li>\n<li><code>s</code>  仅由字母  <code>'a'</code> 、 <code>'b'</code> 、 <code>'c'</code>  组成</li>\n<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong>主打一个逆向思维 + 双指针操作</strong></p>\n<p>要从两边至少分别取 k 个 a，b，c 的字符，剩下的一个连续字符串所含的各字符一定不超过总数减去 k 个。我们要找最小的花费（分钟数），则要找最长的这个连续字符串，且该字符串需要满足上述条件。</p>\n<p>首先对每个字符的数量计数，若有一种字符的出现数量少于 k，那么直接返回 - 1</p>\n<p>然后使用双指针法，遍历左指针的位置，使用右指针去扩大连续字符串的范围，直到满足条件。在左指针向右移动的过程中，<strong>右指针始终递增</strong>，因此可以做到 O (n) 的时间复杂度，而不是 O (n^2) 去遍历两个指针的位置。<strong>注意特殊情况，即当右指针一步也没走出去，以及 right 当前所指位置并未计入有效字符串中。</strong></p>\n<h1 id=\"时间复杂度与空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度与空间复杂度\">#</a> 时间复杂度与空间复杂度</h1>\n<p>时间复杂度：一次遍历，复杂度 O (n)</p>\n<p>空间复杂度：双指针占用常数级空间，即 O (1)</p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">takeCharacters</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        c = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">           c[ch] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[e] &lt; k:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># print(c)</span></span><br><span class=\"line\">        d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        right = <span class=\"number\">0</span></span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> left <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s)):</span><br><span class=\"line\">            <span class=\"comment\"># print(d)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> right &lt; left: <span class=\"comment\">#若right甚至未踏出一步，从新的left开始</span></span><br><span class=\"line\">                right = left</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &lt; <span class=\"built_in\">len</span>(s) <span class=\"keyword\">and</span> d[s[right]] &lt; c[s[right]] - k:</span><br><span class=\"line\">                d[s[right]] += <span class=\"number\">1</span></span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, right - left)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left &lt; right: <span class=\"comment\"># 如果right踏出至少一步，因为left即将左移，那么从字典中减去left所指位置字符的出现数量一次</span></span><br><span class=\"line\">                d[s[left]] -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s) - res</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/",
            "url": "https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/",
            "title": "LeetcodeWeekly-366-04:对数组执行操作使平方和最大",
            "date_published": "2023-10-17T13:04:07.000Z",
            "content_html": "<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组  <code>nums</code>  和一个 <strong>正</strong> 整数  <code>k</code>  。</p>\n<p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p>\n<ul>\n<li>选择两个互不相同的下标  <code>i</code>  和  <code>j</code>  ，<strong>同时</strong> 将  <code>nums[i]</code>  更新为  <code>(nums[i] AND nums[j])</code>  且将  <code>nums[j]</code>  更新为  <code>(nums[i] OR nums[j])</code>  ， <code>OR</code>  表示按位 <strong>或</strong> 运算， <code>AND</code>  表示按位 <strong>与</strong> 运算。</li>\n</ul>\n<p>你需要从最终的数组里选择  <code>k</code>  个元素，并计算它们的 <strong>平方</strong> 之和。</p>\n<p>请你返回你可以得到的 <strong>最大</strong> 平方和。</p>\n<p>由于答案可能会很大，将答案对  <code>109 + 7</code>  <strong>取余</strong> 后返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,6,5,8], k = 2</span><br><span class=\"line\">输出：261</span><br><span class=\"line\">解释：我们可以对数组执行以下操作：</span><br><span class=\"line\">- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。</span><br><span class=\"line\">- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。</span><br><span class=\"line\">从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。</span><br><span class=\"line\">261 是可以得到的最大结果。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,5,4,7], k = 3</span><br><span class=\"line\">输出：90</span><br><span class=\"line\">解释：不需要执行任何操作。</span><br><span class=\"line\">选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。</span><br><span class=\"line\">90 是可以得到的最大结果。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong><u><a href=\"https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a\">解法思路来自 @灵茶山艾府 大佬</a></u></strong></p>\n<p>由于无论是 AND 还是 OR，都不会改变两个数都是 1 或者 0 的结果，因此<strong>题中操作等价于交换两数的 1 和 0，其中 OR 操作后的数会更大，而 AND 操作后的数会更小，并且增大和减小的值相等。</strong></p>\n<p>由于如果把一个数平均分配给两数的平方和一定小于一个数本身的平方，我们的目的是要将尽可能多的 1 转移到一个数上，并执行 k 次这样的操作。</p>\n<p>先遍历整个 nums，找出每一位上有多少个 1，最多 30 位（10<sup>9 小于 2</sup>30），存储在 cnt 里。之后遍历 cnt，只要 cnt 每一位上的数还不为 0，就使临时变量 sum 加上 2^i，cnt 对应位减 1，遍历结束后加在最终的 res 里。执行 k 次以上操作，返回 res。</p>\n<h1 id=\"时间复杂度与空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度与空间复杂度\">#</a> 时间复杂度与空间复杂度</h1>\n<p>时间复杂度 O (n)，空间复杂度 O (1)</p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">maxSum</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        cnt = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">30</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (num != <span class=\"number\">0</span>):</span><br><span class=\"line\">                cnt[i] += num % <span class=\"number\">2</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                num &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k):</span><br><span class=\"line\">            x = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">30</span>):</span><br><span class=\"line\">                t = cnt[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> t:</span><br><span class=\"line\">                    x += <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, i)</span><br><span class=\"line\">                    cnt[i] = t - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            res += x * x</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res % (<span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, <span class=\"number\">9</span>) + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/",
            "url": "https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/",
            "title": "LeetcodeWeekly-366-03:执行操作使两个字符串相等",
            "date_published": "2023-10-15T05:50:21.000Z",
            "content_html": "<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你两个下标从 <strong>0</strong> 开始的二进制字符串  <code>s1</code>  和  <code>s2</code>  ，两个字符串的长度都是  <code>n</code>  ，再给你一个正整数  <code>x</code>  。</p>\n<p>你可以对字符串  <code>s1</code>  执行以下操作 <strong>任意次</strong> ：</p>\n<ul>\n<li>选择两个下标  <code>i</code>  和  <code>j</code>  ，将  <code>s1[i]</code>  和  <code>s1[j]</code>  都反转，操作的代价为  <code>x</code>  。</li>\n<li>选择满足  <code>i &lt; n - 1</code>  的下标  <code>i</code>  ，反转  <code>s1[i]</code>  和  <code>s1[i + 1]</code>  ，操作的代价为  <code>1</code>  。</li>\n</ul>\n<p>请你返回使字符串  <code>s1</code>  和  <code>s2</code>  相等的 <strong>最小</strong> 操作代价之和，如果无法让二者相等，返回  <code>-1</code>  。</p>\n<p><strong>注意</strong> ，反转字符的意思是将  <code>0</code>  变成  <code>1</code>  ，或者  <code>1</code>  变成  <code>0</code>  。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;1100011000&quot;, s2 = &quot;0101001010&quot;, x = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以执行以下操作：</span><br><span class=\"line\">- 选择 i = 3 执行第二个操作。结果字符串是 s1 = &quot;1101111000&quot; 。</span><br><span class=\"line\">- 选择 i = 4 执行第二个操作。结果字符串是 s1 = &quot;1101001000&quot; 。</span><br><span class=\"line\">- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = &quot;0101001010&quot; = s2 。</span><br><span class=\"line\">总代价是 1 + 1 + 2 = 4 。这是最小代价和。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;10110&quot;, s2 = &quot;00011&quot;, x = 4</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法使两个字符串相等。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == s1.length == s2.length</code></li>\n<li><code>1 &lt;= n, x &lt;= 500</code></li>\n<li><code>s1</code>  和  <code>s2</code>  只包含字符  <code>'0'</code>  和  <code>'1'</code>  。</li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong><u><a href=\"https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a\">解法思路来自 @灵茶山艾府 大佬</a></u></strong></p>\n<h2 id=\"解法一on2时间动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一on2时间动态规划\">#</a> 解法一：O (n^2) 时间动态规划</h2>\n<h3 id=\"如何直接判断能否使两个字符串相等\"><a class=\"markdownIt-Anchor\" href=\"#如何直接判断能否使两个字符串相等\">#</a> 如何直接判断能否使两个字符串相等？</h3>\n<p>主要看 s1（或者 s2 也可以）中 **“1” 的数量的奇偶性是否与 s2（或者 s1）中 “1” 的数量的奇偶性 ** 相同。原因是，第一种操作与第二种操作都不会改变 “1” 的数量的奇偶性。第一种操作和第二种操作同时翻转两个位置，要么反转一个 1 一个 0（奇偶性不变），要么反转两个 1 或者两个 0（“1” 的数量 + 2 或 - 2，奇偶性仍不变）。因此若 s1 和 s2 中 “1” 的数量不相同，可以直接返回 - 1.</p>\n<h3 id=\"dp数组的意义递推公式初始化\"><a class=\"markdownIt-Anchor\" href=\"#dp数组的意义递推公式初始化\">#</a> DP 数组的意义，递推公式，初始化</h3>\n<p>三个参数：dp (i, j, preRev)，代表<strong>在处理前 i 个位置后，以及 j 个剩下的免费翻转机会，以及根据 preRev 的真假</strong>（前一个位置是否选择第二种方法进行翻转）的状态下，最小的花费。这是因为，如果在处理先前的字符串时选择了第一种方法，相当于我们在处理之后的字符串时获得了免费的翻转机会。如果前一个位置选择了第二种操作，那么本位需要当作已经被翻转（即如果本来 s1 [2]==‘1’，但 s1 [1] 使用了第二种操作使得 s1 [1] == s2 [1]，那么 s1 [2] 应该被当做 0 来处理）。</p>\n<p>与一般的使用迭代的方法遍历 dp 数组不同，这里使用递归 + cache 的方法来遍历。假如 (s1 [i] == s2 [i]) == <strong>not preRev</strong>，那么 dp (i, j, preRev) = dp (i-1, j, False)。 假如不同，首先分别计算第一种操作和第二种操作后的花费，取最小值。即 dp (i, j, preRev) = min ( dp (i-1, j+1, False) + x, dp (i-1, j, True) + 1 )。之后，假如 j 不为 0，继续计算免费翻转后的花费，即 dp (i, j, preRev) = min (dp (i, j, preRev), dp (i-1, j-1, False))，注意此处等号右边的 dp (i, j, preRev) 已经是第一种和第二种操作取最小值后的值。</p>\n<p>递归在 i==0 时停止，这时假如 j 不为 0，或者 preRev 不为假，则返回无穷大，保证该分支不会被选入最终结果。否则，返回 0，即 s1 和 s2 都为空时，不需要操作。在主函数中，直接返回 dp (len (s1), 0, False) 的结果。</p>\n<h3 id=\"时间复杂度和空间复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度和空间复杂度分析\">#</a> 时间复杂度和空间复杂度分析</h3>\n<p>计算思路：状态数 * 单个状态下的计算复杂度。因为 i 和 j 分别可以最多可以取到 len (s1)，preRev 的状态集有限，且计算单个状态的时间复杂度是 O (1) ，则总体的时间复杂度为 O (n<sup>2)。同理，空间复杂度也为 O (n</sup>2)。</p>\n<h3 id=\"python代码实现\"><a class=\"markdownIt-Anchor\" href=\"#python代码实现\">#</a> Python 代码实现</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minOperations</span>(<span class=\"params\">self, s1: <span class=\"built_in\">str</span>, s2: <span class=\"built_in\">str</span>, x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span> != s2.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">i, j, preRev</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> preRev:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> inf</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((s1[i-<span class=\"number\">1</span>] == s2[i-<span class=\"number\">1</span>]) == (<span class=\"keyword\">not</span> preRev)):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dfs(i-<span class=\"number\">1</span>, j, <span class=\"literal\">False</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            t = <span class=\"built_in\">min</span>(dfs(i - <span class=\"number\">1</span>, j + <span class=\"number\">1</span>, <span class=\"literal\">False</span>) + x, dfs(i - <span class=\"number\">1</span>, j, <span class=\"literal\">True</span>) + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j:</span><br><span class=\"line\">                t = <span class=\"built_in\">min</span>(t, dfs(i - <span class=\"number\">1</span>, j - <span class=\"number\">1</span>, <span class=\"literal\">False</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(<span class=\"built_in\">len</span>(s1), <span class=\"number\">0</span>, <span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"解法二on时间动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法二on时间动态规划\">#</a> 解法二：O (n) 时间动态规划</h2>\n<p>单次遍历 s1，记录下与 s2 每个位置上不同的下标，并存储在一个新数组 p 中。</p>\n<h3 id=\"如何直接判断能否使两个字符串相等-2\"><a class=\"markdownIt-Anchor\" href=\"#如何直接判断能否使两个字符串相等-2\">#</a> 如何直接判断能否使两个字符串相等？</h3>\n<p>两种操作每次都需要正好对两个数操作，则假如 p 的长度为奇数，那么可以直接返回 - 1。</p>\n<h3 id=\"动态规划意义及递推公式初始化\"><a class=\"markdownIt-Anchor\" href=\"#动态规划意义及递推公式初始化\">#</a> 动态规划意义及递推公式，初始化</h3>\n<p>设 f (i) 为处理数组 p 前 i 个元素所需要花费的时间</p>\n<p>来看如何处理当前位置为 i 的元素：对于第一种操作，花费可看作是 x/2，即 f (i) = f (i-1) + x/2。对于第二种操作，需要看上一个位置与该位置的 “距离”，连续翻转之间的数，即 f (i) = f (i-2) + p [i-1] - p [i]。</p>\n<p>因此 f (0)=0,f (1)=x/2</p>\n<h3 id=\"时间复杂度和空间复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度和空间复杂度分析-2\">#</a> 时间复杂度和空间复杂度分析</h3>\n<p>对于每个 f (i)，我们只需要知道 f (i-1) 和 f (i-2)，因此我们需要维护两个状态（滚动数组），最后返回其中第一个状态。时间复杂度 O (n)，空间复杂度 O (n)。</p>\n<h3 id=\"python代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#python代码实现-2\">#</a> Python 代码实现</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minOperations</span>(<span class=\"params\">self, s1: <span class=\"built_in\">str</span>, s2: <span class=\"built_in\">str</span>, x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        p = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s1)) <span class=\"keyword\">if</span> s1[i] != s2[i]]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        f0, f1 = <span class=\"number\">0</span>, x / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> pairwise(p):</span><br><span class=\"line\">            f0, f1 = f1, <span class=\"built_in\">min</span>(f1 + x / <span class=\"number\">2</span>, f0 + j - i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(f1)</span><br></pre></td></tr></table></figure>\n<h1 id=\"思考题\"><a class=\"markdownIt-Anchor\" href=\"#思考题\">#</a> 思考题</h1>\n<p><strong>如果第一种操作限制 | i-j|&gt;=k 呢？</strong></p>\n<p>可以多维护一个整数参数 t，记录下一个可以进行免费翻转的下标位置，即如果使用第一种操作，那么 t 更新为 i+k。在判断是否能免费翻转时，除了 j 还需要看当前 i 是否大于等于 t，如果都满足的话才能免费翻转。</p>\n",
            "tags": [
                "Code"
            ]
        }
    ]
}