{
    "version": "https://jsonfeed.org/version/1",
    "title": "PaperWings Blog • All posts by \"code\" tag",
    "description": "",
    "home_page_url": "https://paperwings2019.github.io",
    "items": [
        {
            "id": "https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/",
            "url": "https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/",
            "title": "Leetcode-2516-每种字符至少取 K 个",
            "date_published": "2023-10-18T15:31:57.000Z",
            "content_html": "<p>hexo</p>\n<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个由字符  <code>'a'</code> 、 <code>'b'</code> 、 <code>'c'</code>  组成的字符串  <code>s</code>  和一个非负整数  <code>k</code>  。每分钟，你可以选择取走  <code>s</code>  <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>\n<p>你必须取走每种字符 <strong>至少</strong>  <code>k</code>  个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回  <code>-1</code>  。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;aabaaaacaabc&quot;, k = 2</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。</span><br><span class=\"line\">从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。</span><br><span class=\"line\">共需要 3 + 5 = 8 分钟。</span><br><span class=\"line\">可以证明需要的最少分钟数是 8 。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;, k = 1</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -1 。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 105</code></li>\n<li><code>s</code>  仅由字母  <code>'a'</code> 、 <code>'b'</code> 、 <code>'c'</code>  组成</li>\n<li><code>0 &lt;= k &lt;= s.length</code></li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong>主打一个逆向思维 + 双指针操作</strong></p>\n<p>要从两边至少分别取 k 个 a，b，c 的字符，剩下的一个连续字符串所含的各字符一定不超过总数减去 k 个。我们要找最小的花费（分钟数），则要找最长的这个连续字符串，且该字符串需要满足上述条件。</p>\n<p>首先对每个字符的数量计数，若有一种字符的出现数量少于 k，那么直接返回 - 1</p>\n<p>然后使用双指针法，遍历左指针的位置，使用右指针去扩大连续字符串的范围，直到满足条件。在左指针向右移动的过程中，<strong>右指针始终递增</strong>，因此可以做到 O (n) 的时间复杂度，而不是 O (n^2) 去遍历两个指针的位置。<strong>注意特殊情况，即当右指针一步也没走出去，以及 right 当前所指位置并未计入有效字符串中。</strong></p>\n<h1 id=\"时间复杂度与空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度与空间复杂度\">#</a> 时间复杂度与空间复杂度</h1>\n<p>时间复杂度：一次遍历，复杂度 O (n)</p>\n<p>空间复杂度：双指针占用常数级空间，即 O (1)</p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">takeCharacters</span>(<span class=\"params\">self, s: <span class=\"built_in\">str</span>, k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        c = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">           c[ch] += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> c:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> c[e] &lt; k:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\"># print(c)</span></span><br><span class=\"line\">        d = &#123;<span class=\"string\">&#x27;a&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;b&#x27;</span>:<span class=\"number\">0</span>, <span class=\"string\">&#x27;c&#x27;</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        right = <span class=\"number\">0</span></span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> left <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s)):</span><br><span class=\"line\">            <span class=\"comment\"># print(d)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> right &lt; left: <span class=\"comment\">#若right甚至未踏出一步，从新的left开始</span></span><br><span class=\"line\">                right = left</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> right &lt; <span class=\"built_in\">len</span>(s) <span class=\"keyword\">and</span> d[s[right]] &lt; c[s[right]] - k:</span><br><span class=\"line\">                d[s[right]] += <span class=\"number\">1</span></span><br><span class=\"line\">                right += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, right - left)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> left &lt; right: <span class=\"comment\"># 如果right踏出至少一步，因为left即将左移，那么从字典中减去left所指位置字符的出现数量一次</span></span><br><span class=\"line\">                d[s[left]] -= <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(s) - res</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/",
            "url": "https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/",
            "title": "LeetcodeWeekly-366-04:对数组执行操作使平方和最大",
            "date_published": "2023-10-17T13:04:07.000Z",
            "content_html": "<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个下标从 <strong>0</strong> 开始的整数数组  <code>nums</code>  和一个 <strong>正</strong> 整数  <code>k</code>  。</p>\n<p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p>\n<ul>\n<li>选择两个互不相同的下标  <code>i</code>  和  <code>j</code>  ，<strong>同时</strong> 将  <code>nums[i]</code>  更新为  <code>(nums[i] AND nums[j])</code>  且将  <code>nums[j]</code>  更新为  <code>(nums[i] OR nums[j])</code>  ， <code>OR</code>  表示按位 <strong>或</strong> 运算， <code>AND</code>  表示按位 <strong>与</strong> 运算。</li>\n</ul>\n<p>你需要从最终的数组里选择  <code>k</code>  个元素，并计算它们的 <strong>平方</strong> 之和。</p>\n<p>请你返回你可以得到的 <strong>最大</strong> 平方和。</p>\n<p>由于答案可能会很大，将答案对  <code>109 + 7</code>  <strong>取余</strong> 后返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,6,5,8], k = 2</span><br><span class=\"line\">输出：261</span><br><span class=\"line\">解释：我们可以对数组执行以下操作：</span><br><span class=\"line\">- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。</span><br><span class=\"line\">- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。</span><br><span class=\"line\">从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。</span><br><span class=\"line\">261 是可以得到的最大结果。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [4,5,4,7], k = 3</span><br><span class=\"line\">输出：90</span><br><span class=\"line\">解释：不需要执行任何操作。</span><br><span class=\"line\">选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。</span><br><span class=\"line\">90 是可以得到的最大结果。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong><u><a href=\"https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a\">解法思路来自 @灵茶山艾府 大佬</a></u></strong></p>\n<p>由于无论是 AND 还是 OR，都不会改变两个数都是 1 或者 0 的结果，因此<strong>题中操作等价于交换两数的 1 和 0，其中 OR 操作后的数会更大，而 AND 操作后的数会更小，并且增大和减小的值相等。</strong></p>\n<p>由于如果把一个数平均分配给两数的平方和一定小于一个数本身的平方，我们的目的是要将尽可能多的 1 转移到一个数上，并执行 k 次这样的操作。</p>\n<p>先遍历整个 nums，找出每一位上有多少个 1，最多 30 位（10<sup>9 小于 2</sup>30），存储在 cnt 里。之后遍历 cnt，只要 cnt 每一位上的数还不为 0，就使临时变量 sum 加上 2^i，cnt 对应位减 1，遍历结束后加在最终的 res 里。执行 k 次以上操作，返回 res。</p>\n<h1 id=\"时间复杂度与空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度与空间复杂度\">#</a> 时间复杂度与空间复杂度</h1>\n<p>时间复杂度 O (n)，空间复杂度 O (1)</p>\n<h1 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h1>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">maxSum</span>(<span class=\"params\">self, nums: <span class=\"type\">List</span>[<span class=\"built_in\">int</span>], k: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        cnt = [<span class=\"number\">0</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">30</span>)]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">            i = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (num != <span class=\"number\">0</span>):</span><br><span class=\"line\">                cnt[i] += num % <span class=\"number\">2</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">                num &gt;&gt;= <span class=\"number\">1</span></span><br><span class=\"line\">        res = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(k):</span><br><span class=\"line\">            x = <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">30</span>):</span><br><span class=\"line\">                t = cnt[i]</span><br><span class=\"line\">                <span class=\"keyword\">if</span> t:</span><br><span class=\"line\">                    x += <span class=\"built_in\">pow</span>(<span class=\"number\">2</span>, i)</span><br><span class=\"line\">                    cnt[i] = t - <span class=\"number\">1</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            res += x * x</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res % (<span class=\"built_in\">pow</span>(<span class=\"number\">10</span>, <span class=\"number\">9</span>) + <span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Code"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/",
            "url": "https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/",
            "title": "LeetcodeWeekly-366-03:执行操作使两个字符串相等",
            "date_published": "2023-10-15T05:50:21.000Z",
            "content_html": "<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你两个下标从 <strong>0</strong> 开始的二进制字符串  <code>s1</code>  和  <code>s2</code>  ，两个字符串的长度都是  <code>n</code>  ，再给你一个正整数  <code>x</code>  。</p>\n<p>你可以对字符串  <code>s1</code>  执行以下操作 <strong>任意次</strong> ：</p>\n<ul>\n<li>选择两个下标  <code>i</code>  和  <code>j</code>  ，将  <code>s1[i]</code>  和  <code>s1[j]</code>  都反转，操作的代价为  <code>x</code>  。</li>\n<li>选择满足  <code>i &lt; n - 1</code>  的下标  <code>i</code>  ，反转  <code>s1[i]</code>  和  <code>s1[i + 1]</code>  ，操作的代价为  <code>1</code>  。</li>\n</ul>\n<p>请你返回使字符串  <code>s1</code>  和  <code>s2</code>  相等的 <strong>最小</strong> 操作代价之和，如果无法让二者相等，返回  <code>-1</code>  。</p>\n<p><strong>注意</strong> ，反转字符的意思是将  <code>0</code>  变成  <code>1</code>  ，或者  <code>1</code>  变成  <code>0</code>  。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;1100011000&quot;, s2 = &quot;0101001010&quot;, x = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：我们可以执行以下操作：</span><br><span class=\"line\">- 选择 i = 3 执行第二个操作。结果字符串是 s1 = &quot;1101111000&quot; 。</span><br><span class=\"line\">- 选择 i = 4 执行第二个操作。结果字符串是 s1 = &quot;1101001000&quot; 。</span><br><span class=\"line\">- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = &quot;0101001010&quot; = s2 。</span><br><span class=\"line\">总代价是 1 + 1 + 2 = 4 。这是最小代价和。</span><br></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s1 = &quot;10110&quot;, s2 = &quot;00011&quot;, x = 4</span><br><span class=\"line\">输出：-1</span><br><span class=\"line\">解释：无法使两个字符串相等。</span><br></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == s1.length == s2.length</code></li>\n<li><code>1 &lt;= n, x &lt;= 500</code></li>\n<li><code>s1</code>  和  <code>s2</code>  只包含字符  <code>'0'</code>  和  <code>'1'</code>  。</li>\n</ul>\n<h1 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h1>\n<p><strong><u><a href=\"https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a\">解法思路来自 @灵茶山艾府 大佬</a></u></strong></p>\n<h2 id=\"解法一on2时间动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一on2时间动态规划\">#</a> 解法一：O (n^2) 时间动态规划</h2>\n<h3 id=\"如何直接判断能否使两个字符串相等\"><a class=\"markdownIt-Anchor\" href=\"#如何直接判断能否使两个字符串相等\">#</a> 如何直接判断能否使两个字符串相等？</h3>\n<p>主要看 s1（或者 s2 也可以）中 **“1” 的数量的奇偶性是否与 s2（或者 s1）中 “1” 的数量的奇偶性 ** 相同。原因是，第一种操作与第二种操作都不会改变 “1” 的数量的奇偶性。第一种操作和第二种操作同时翻转两个位置，要么反转一个 1 一个 0（奇偶性不变），要么反转两个 1 或者两个 0（“1” 的数量 + 2 或 - 2，奇偶性仍不变）。因此若 s1 和 s2 中 “1” 的数量不相同，可以直接返回 - 1.</p>\n<h3 id=\"dp数组的意义递推公式初始化\"><a class=\"markdownIt-Anchor\" href=\"#dp数组的意义递推公式初始化\">#</a> DP 数组的意义，递推公式，初始化</h3>\n<p>三个参数：dp (i, j, preRev)，代表<strong>在处理前 i 个位置后，以及 j 个剩下的免费翻转机会，以及根据 preRev 的真假</strong>（前一个位置是否选择第二种方法进行翻转）的状态下，最小的花费。这是因为，如果在处理先前的字符串时选择了第一种方法，相当于我们在处理之后的字符串时获得了免费的翻转机会。如果前一个位置选择了第二种操作，那么本位需要当作已经被翻转（即如果本来 s1 [2]==‘1’，但 s1 [1] 使用了第二种操作使得 s1 [1] == s2 [1]，那么 s1 [2] 应该被当做 0 来处理）。</p>\n<p>与一般的使用迭代的方法遍历 dp 数组不同，这里使用递归 + cache 的方法来遍历。假如 (s1 [i] == s2 [i]) == <strong>not preRev</strong>，那么 dp (i, j, preRev) = dp (i-1, j, False)。 假如不同，首先分别计算第一种操作和第二种操作后的花费，取最小值。即 dp (i, j, preRev) = min ( dp (i-1, j+1, False) + x, dp (i-1, j, True) + 1 )。之后，假如 j 不为 0，继续计算免费翻转后的花费，即 dp (i, j, preRev) = min (dp (i, j, preRev), dp (i-1, j-1, False))，注意此处等号右边的 dp (i, j, preRev) 已经是第一种和第二种操作取最小值后的值。</p>\n<p>递归在 i==0 时停止，这时假如 j 不为 0，或者 preRev 不为假，则返回无穷大，保证该分支不会被选入最终结果。否则，返回 0，即 s1 和 s2 都为空时，不需要操作。在主函数中，直接返回 dp (len (s1), 0, False) 的结果。</p>\n<h3 id=\"时间复杂度和空间复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度和空间复杂度分析\">#</a> 时间复杂度和空间复杂度分析</h3>\n<p>计算思路：状态数 * 单个状态下的计算复杂度。因为 i 和 j 分别可以最多可以取到 len (s1)，preRev 的状态集有限，且计算单个状态的时间复杂度是 O (1) ，则总体的时间复杂度为 O (n<sup>2)。同理，空间复杂度也为 O (n</sup>2)。</p>\n<h3 id=\"python代码实现\"><a class=\"markdownIt-Anchor\" href=\"#python代码实现\">#</a> Python 代码实现</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minOperations</span>(<span class=\"params\">self, s1: <span class=\"built_in\">str</span>, s2: <span class=\"built_in\">str</span>, x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span> != s2.count(<span class=\"string\">&#x27;1&#x27;</span>) % <span class=\"number\">2</span>):</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">        @cache</span></span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">i, j, preRev</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j == <span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> preRev:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> inf</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((s1[i-<span class=\"number\">1</span>] == s2[i-<span class=\"number\">1</span>]) == (<span class=\"keyword\">not</span> preRev)):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dfs(i-<span class=\"number\">1</span>, j, <span class=\"literal\">False</span>)</span><br><span class=\"line\">            </span><br><span class=\"line\">            t = <span class=\"built_in\">min</span>(dfs(i - <span class=\"number\">1</span>, j + <span class=\"number\">1</span>, <span class=\"literal\">False</span>) + x, dfs(i - <span class=\"number\">1</span>, j, <span class=\"literal\">True</span>) + <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> j:</span><br><span class=\"line\">                t = <span class=\"built_in\">min</span>(t, dfs(i - <span class=\"number\">1</span>, j - <span class=\"number\">1</span>, <span class=\"literal\">False</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(<span class=\"built_in\">len</span>(s1), <span class=\"number\">0</span>, <span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"解法二on时间动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法二on时间动态规划\">#</a> 解法二：O (n) 时间动态规划</h2>\n<p>单次遍历 s1，记录下与 s2 每个位置上不同的下标，并存储在一个新数组 p 中。</p>\n<h3 id=\"如何直接判断能否使两个字符串相等-2\"><a class=\"markdownIt-Anchor\" href=\"#如何直接判断能否使两个字符串相等-2\">#</a> 如何直接判断能否使两个字符串相等？</h3>\n<p>两种操作每次都需要正好对两个数操作，则假如 p 的长度为奇数，那么可以直接返回 - 1。</p>\n<h3 id=\"动态规划意义及递推公式初始化\"><a class=\"markdownIt-Anchor\" href=\"#动态规划意义及递推公式初始化\">#</a> 动态规划意义及递推公式，初始化</h3>\n<p>设 f (i) 为处理数组 p 前 i 个元素所需要花费的时间</p>\n<p>来看如何处理当前位置为 i 的元素：对于第一种操作，花费可看作是 x/2，即 f (i) = f (i-1) + x/2。对于第二种操作，需要看上一个位置与该位置的 “距离”，连续翻转之间的数，即 f (i) = f (i-2) + p [i-1] - p [i]。</p>\n<p>因此 f (0)=0,f (1)=x/2</p>\n<h3 id=\"时间复杂度和空间复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#时间复杂度和空间复杂度分析-2\">#</a> 时间复杂度和空间复杂度分析</h3>\n<p>对于每个 f (i)，我们只需要知道 f (i-1) 和 f (i-2)，因此我们需要维护两个状态（滚动数组），最后返回其中第一个状态。时间复杂度 O (n)，空间复杂度 O (n)。</p>\n<h3 id=\"python代码实现-2\"><a class=\"markdownIt-Anchor\" href=\"#python代码实现-2\">#</a> Python 代码实现</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">minOperations</span>(<span class=\"params\">self, s1: <span class=\"built_in\">str</span>, s2: <span class=\"built_in\">str</span>, x: <span class=\"built_in\">int</span></span>) -&gt; <span class=\"built_in\">int</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> s1 == s2: <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        p = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(s1)) <span class=\"keyword\">if</span> s1[i] != s2[i]]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(p) % <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">        f0, f1 = <span class=\"number\">0</span>, x / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> pairwise(p):</span><br><span class=\"line\">            f0, f1 = f1, <span class=\"built_in\">min</span>(f1 + x / <span class=\"number\">2</span>, f0 + j - i)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">int</span>(f1)</span><br></pre></td></tr></table></figure>\n<h1 id=\"思考题\"><a class=\"markdownIt-Anchor\" href=\"#思考题\">#</a> 思考题</h1>\n<p><strong>如果第一种操作限制 | i-j|&gt;=k 呢？</strong></p>\n<p>可以多维护一个整数参数 t，记录下一个可以进行免费翻转的下标位置，即如果使用第一种操作，那么 t 更新为 i+k。在判断是否能免费翻转时，除了 j 还需要看当前 i 是否大于等于 t，如果都满足的话才能免费翻转。</p>\n",
            "tags": [
                "Code"
            ]
        }
    ]
}