<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://paperwings2019.github.io</id>
    <title>PaperWings Blog • Posts by &#34;code&#34; tag</title>
    <link href="https://paperwings2019.github.io" />
    <updated>2024-03-10T12:48:16.000Z</updated>
    <category term="Code" />
    <category term="Daily" />
    <entry>
        <id>https://paperwings2019.github.io/2024/03/10/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
        <title>Linux学习笔记</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2024/03/10/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
        <content type="html">&lt;p&gt;PS：该学习笔记资源来自于&lt;a href=&#34;https://linux.vbird.org/&#34;&gt;鸟叔的linux私房菜&lt;/a&gt;，感谢大佬～&lt;/p&gt;
&lt;p&gt;PPS：由于在学习时已经有了一定计算机基础，于是直接从第二章开始做笔记！&lt;/p&gt;
&lt;h1 id=&#34;主机结构与磁盘分区&#34;&gt;&lt;a href=&#34;#主机结构与磁盘分区&#34; class=&#34;headerlink&#34; title=&#34;主机结构与磁盘分区&#34;&gt;&lt;/a&gt;主机结构与磁盘分区&lt;/h1&gt;&lt;h2 id=&#34;使用合适的硬件搭建Linux系统&#34;&gt;&lt;a href=&#34;#使用合适的硬件搭建Linux系统&#34; class=&#34;headerlink&#34; title=&#34;使用合适的硬件搭建Linux系统&#34;&gt;&lt;/a&gt;使用合适的硬件搭建Linux系统&lt;/h2&gt;&lt;p&gt;在搭建Linux系统时，硬件的选配也很重要，在购买之前一定要查看其对于Linux的支持性。针对不同的需求，如办公或者是作为服务器，也需要选配不同等级的硬件，如CPU，内存，网卡，磁盘等。&lt;/p&gt;
&lt;h2 id=&#34;磁盘分区&#34;&gt;&lt;a href=&#34;#磁盘分区&#34; class=&#34;headerlink&#34; title=&#34;磁盘分区&#34;&gt;&lt;/a&gt;磁盘分区&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在Linux中，设备在文件系统中就是一个文件夹或者文件。&lt;/strong&gt;对于不同类型的存储装置&amp;#x2F;设备，Linux会按照以下的规则进行命名：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;裝置&lt;/th&gt;
&lt;th&gt;裝置在Linux內的檔名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;SCSI&amp;#x2F;SATA&amp;#x2F;USB硬碟機&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;sd[a-p]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USB快閃碟&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;sd[a-p] (與SATA相同)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VirtI&amp;#x2F;O界面&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;vd[a-p] (用於虛擬機器內)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;軟碟機&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;fd[0-1]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;印表機&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;lp[0-2] (25針印表機) &amp;#x2F;dev&amp;#x2F;usb&amp;#x2F;lp[0-15] (USB 介面)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;滑鼠&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;input&amp;#x2F;mouse[0-15] (通用) &amp;#x2F;dev&amp;#x2F;psaux (PS&amp;#x2F;2界面) &amp;#x2F;dev&amp;#x2F;mouse (當前滑鼠)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CDROM&amp;#x2F;DVDROM&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;scd[0-1] (通用) &amp;#x2F;dev&amp;#x2F;sr[0-1] (通用，CentOS 較常見) &amp;#x2F;dev&amp;#x2F;cdrom (當前 CDROM)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;磁帶機&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;ht0 (IDE 界面) &amp;#x2F;dev&amp;#x2F;st0 (SATA&amp;#x2F;SCSI界面) &amp;#x2F;dev&amp;#x2F;tape (當前磁帶)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDE硬碟機&lt;/td&gt;
&lt;td&gt;&amp;#x2F;dev&amp;#x2F;hd[a-d] (舊式系統才有)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;一般来说，支持SATA的磁盘会以&amp;#x2F;dev&amp;#x2F;sd[a-p]来命名，而虚拟磁盘（如在虚拟机内的磁盘）会以&amp;#x2F;dev&amp;#x2F;vd[a-p]来命名。&lt;strong&gt;那么假设主板上安装了多个SATA磁盘&amp;#x2F;USB硬盘，如何决定他们的命名顺序呢？答案是以侦测到的顺序来决定，先侦测到的磁盘会有更“前”的名字。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例題：&lt;/p&gt;
&lt;p&gt;如果你的PC上面有兩個SATA磁碟以及一個USB磁碟，而主機板上面有六個SATA的插槽。這兩個SATA磁碟分別安插在主機板上的SATA1, SATA5插槽上， 請問這三個磁碟在Linux中的裝置檔名為何？&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;由於是使用偵測到的順序來決定裝置檔名，並非與實際插槽代號有關，因此裝置的檔名如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SATA1插槽上的檔名：&amp;#x2F;dev&amp;#x2F;sda&lt;/li&gt;
&lt;li&gt;SATA5插槽上的檔名：&amp;#x2F;dev&amp;#x2F;sdb&lt;/li&gt;
&lt;li&gt;USB磁碟(開機完成後才被系統捉到)：&amp;#x2F;dev&amp;#x2F;sdc&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;那假如一个磁盘被分成多个区，那么每个区的命名又该如何？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/2024/03/10/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240310210203478.png&#34; alt=&#34;image-20240310210203478&#34;&gt;&lt;/p&gt;
</content>
        <category term="Code" />
        <updated>2024-03-10T12:48:16.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</id>
        <title>C语言常见面试/笔试问题集合</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/24/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
        <content type="html">&lt;h1 id=&#34;概念问题&#34;&gt;&lt;a href=&#34;#概念问题&#34; class=&#34;headerlink&#34; title=&#34;概念问题&#34;&gt;&lt;/a&gt;概念问题&lt;/h1&gt;&lt;h2 id=&#34;static关键字的作用-原理&#34;&gt;&lt;a href=&#34;#static关键字的作用-原理&#34; class=&#34;headerlink&#34; title=&#34;static关键字的作用&amp;#x2F;原理&#34;&gt;&lt;/a&gt;static关键字的作用&amp;#x2F;原理&lt;/h2&gt;&lt;p&gt;被static修饰的变量或者函数会被放入静态存储区。根据上下文，static有不同的作用和意义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在函数体内部声明的static修饰的变量将被作为静态局部变量。其作用域或者可见范围仍被限制在函数内，即只在函数运行时才能进行访问，但其初始化将在整个程序刚开始运行时就进行，有且仅有一次。这意味着无论多少次调用该函数，该static变量不会重新被初始化，而是会继续保持在上一次的值。其寿命等于程序运行寿命。&lt;/li&gt;
&lt;li&gt;一般被static修饰的全局变量仅能在一个模块（文件）内可见，而不能被其他模块访问。全局变量仍然被放入静态区，但是可见范围发生了以上变化。&lt;/li&gt;
&lt;li&gt;被static修饰的函数声明表示该函数只在当前模块可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;volatile关键字的作用-原理&#34;&gt;&lt;a href=&#34;#volatile关键字的作用-原理&#34; class=&#34;headerlink&#34; title=&#34;volatile关键字的作用&amp;#x2F;原理&#34;&gt;&lt;/a&gt;volatile关键字的作用&amp;#x2F;原理&lt;/h2&gt;&lt;p&gt;被volatile修饰的变量，编译器不会对其进行优化，因为该变量可能会受到意想不到的变化，而读取寄存器内的旧值可能会使程序向意料之外的方向发展。具体场景如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在多任务场景下，某变量可能需要被多个任务所访问，因此可能随时变化。该变量需要被volatile修饰，使得编译器不对其进行优化。&lt;/li&gt;
&lt;li&gt;在中断服务场景下，某变量可能被作为中断被触发的标志，而读取旧值会使中断不能及时发生。该变量应该被volatile修饰来确保中断能够及时触发。&lt;/li&gt;
&lt;li&gt;在一些硬件寄存器控制场景下，我们可能需要对一些寄存器地址做一些特殊操作。例如我们需要初始化一个硬件，我们需要对其进行循环赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存管理问题&#34;&gt;&lt;a href=&#34;#内存管理问题&#34; class=&#34;headerlink&#34; title=&#34;内存管理问题&#34;&gt;&lt;/a&gt;内存管理问题&lt;/h2&gt;&lt;h3 id=&#34;内存分配函数&#34;&gt;&lt;a href=&#34;#内存分配函数&#34; class=&#34;headerlink&#34; title=&#34;内存分配函数&#34;&gt;&lt;/a&gt;内存分配函数&lt;/h3&gt;&lt;h4 id=&#34;解释malloc、calloc、realloc的区别和用法&#34;&gt;&lt;a href=&#34;#解释malloc、calloc、realloc的区别和用法&#34; class=&#34;headerlink&#34; title=&#34;解释malloc、calloc、realloc的区别和用法&#34;&gt;&lt;/a&gt;解释&lt;code&gt;malloc&lt;/code&gt;、&lt;code&gt;calloc&lt;/code&gt;、&lt;code&gt;realloc&lt;/code&gt;的区别和用法&lt;/h4&gt;&lt;p&gt;malloc用于在&lt;strong&gt;堆&lt;/strong&gt;（heap）上动态分配一个指定大小和类型的内存块，但不会初始化内存中的值&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组,但未初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;calloc用于在堆上动态分配一个指定大小和类型的内存块，并将内存中的值初始化为0&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;calloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组，初始化各元素为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;realloc用于将malloc或者calloc分配的内存扩大或者缩小&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt; * &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;)); &lt;span class=&#34;comment&#34;&gt;// 分配一个大小为10的整型数组,但未初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;realloc&lt;/span&gt;(arr, &lt;span class=&#34;number&#34;&gt;12&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;built_in&#34;&gt;realloc&lt;/span&gt;(arr, &lt;span class=&#34;number&#34;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意，假如realloc后无法在原地扩展，则会在堆heap中另外寻找一块合适的内存块，并自动释放之前的内存&lt;/p&gt;
&lt;h4 id=&#34;什么是内存泄漏（Memory-Leak）和悬挂指针（Dangling-Pointer）？如何避免内存泄漏和悬挂指针？&#34;&gt;&lt;a href=&#34;#什么是内存泄漏（Memory-Leak）和悬挂指针（Dangling-Pointer）？如何避免内存泄漏和悬挂指针？&#34; class=&#34;headerlink&#34; title=&#34;什么是内存泄漏（Memory Leak）和悬挂指针（Dangling Pointer）？如何避免内存泄漏和悬挂指针？&#34;&gt;&lt;/a&gt;什么是内存泄漏（Memory Leak）和悬挂指针（Dangling Pointer）？如何避免内存泄漏和悬挂指针？&lt;/h4&gt;&lt;p&gt;内存泄漏指程序员未能成功释放动态分配（如malloc，calloc，realloc）的内存，导致分配的内存一直被占用造成浪费，从而导致程序运行变慢或崩溃。悬挂指针指当某指针所指的内存被释放后，该指针仍然指向原内存地址，再次访问会出现不可预知的行为，变成悬挂指针。悬挂指针也有可能因为存储了局部变量的地址而造成，如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;* &lt;span class=&#34;title function_&#34;&gt;creatInt&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *x = (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*)&lt;span class=&#34;built_in&#34;&gt;malloc&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;  &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *ptr = creatInt(); &lt;span class=&#34;comment&#34;&gt;// ptr存储局部变量的地址，是悬挂指针&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;为了避免内存泄漏，应该在分配的内存使用完毕后及时使用free函数释放。注意不要重复释放内存，并在释放内存后及时将NULL赋值给原指针，避免出现悬挂指针。若在声明指针时未进行初始化，也会出现悬挂指针。也可以使用智能指针，程序会自动释放内存。&lt;/p&gt;
&lt;h4 id=&#34;什么是内存对齐？为什么要内存对齐？内存对齐会发生什么？&#34;&gt;&lt;a href=&#34;#什么是内存对齐？为什么要内存对齐？内存对齐会发生什么？&#34; class=&#34;headerlink&#34; title=&#34;什么是内存对齐？为什么要内存对齐？内存对齐会发生什么？&#34;&gt;&lt;/a&gt;什么是内存对齐？为什么要内存对齐？内存对齐会发生什么？&lt;/h4&gt;&lt;p&gt;内存对齐指为了获得更快的运行速度，数据在内存中的存放首地址一般都为4的倍数，而不是连续存放。一个简单的例子：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c; &lt;span class=&#34;comment&#34;&gt;// char 占一个byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i; &lt;span class=&#34;comment&#34;&gt;// int 占四个byte&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;x;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;, &lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(x)); &lt;span class=&#34;comment&#34;&gt;// 输出8,而不是5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这是因为char只占一个byte，而对于32位系统来说，地址只能以4的倍数去访问。也就说，一个32位（4字节）内存段内，第一个char只占据了一个字节，剩下三个字节并不能用于存放int的前三个字节，而是只能空出，并在下一个连续的4字节段内存放int。这样以来，struct x的大小总共就为8。&lt;/p&gt;
&lt;p&gt;内存对齐的原因是，假如没有该机制，我们可能需要对不同的4字节段分别取一部分再组合到一起，而这增加了操作的时间和成本。假如我们遵循内存对齐，那么我们访问数据时就可以直接读取。&lt;/p&gt;
&lt;p&gt;在决定一个结构体的size时，需要看各元素之间的大小，有时我们需要垫空白字节，有时不需要。观察以下例子。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//32位系统&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;keyword&#34;&gt;include&lt;/span&gt;&lt;span class=&#34;string&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c1;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c2;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;x1;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c1;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c2;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;x2;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c1;  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;char&lt;/span&gt; c2; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; i;    &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;x3;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(x1));  &lt;span class=&#34;comment&#34;&gt;// 输出8 = 4 + ((1 + 1) + 2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(x2));  &lt;span class=&#34;comment&#34;&gt;// 输出12 = ((1) + 3) + 4 + ((1) + 3)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;printf&lt;/span&gt;(&lt;span class=&#34;string&#34;&gt;&amp;quot;%d\n&amp;quot;&lt;/span&gt;,&lt;span class=&#34;keyword&#34;&gt;sizeof&lt;/span&gt;(x3));  &lt;span class=&#34;comment&#34;&gt;// 输出8 = ((1 + 1) + 2) + 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 作者：忆臻&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 链接：https://zhuanlan.zhihu.com/p/30007037&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;// 来源：知乎&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;数组和指针&#34;&gt;&lt;a href=&#34;#数组和指针&#34; class=&#34;headerlink&#34; title=&#34;数组和指针&#34;&gt;&lt;/a&gt;数组和指针&lt;/h3&gt;&lt;h4 id=&#34;指针和数组有什么区别？如何将指针和数组相互转换？&#34;&gt;&lt;a href=&#34;#指针和数组有什么区别？如何将指针和数组相互转换？&#34; class=&#34;headerlink&#34; title=&#34;指针和数组有什么区别？如何将指针和数组相互转换？&#34;&gt;&lt;/a&gt;指针和数组有什么区别？如何将指针和数组相互转换？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;定义和使用&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; a[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;]; &lt;span class=&#34;comment&#34;&gt;// 数组，需要确定数组的大小，元素的类型，元素的类型必须相同，在内存中以连续地址分布&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *p; &lt;span class=&#34;comment&#34;&gt;// 指针，需要指定指向数据的类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;内存中的表示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组在内存中连续分布，有固定的大小，每个元素占据相应的内存大小&lt;/p&gt;
&lt;p&gt;指针在内存中表示所指向的量的地址，自己本身也有一个地址。在不同的操作系统中存储的地址或者本身的地址都可能不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相互转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义的数组名称其实就是一个指针，指向所被分配的内存空间中的首地址。作为函数参数时，两者都是等效的，如下：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; arr[])&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *arr)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;无论使用哪一类参数传入，都需要注意数组的上限，注意不能越界，否则会发生意外。&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; arr[&lt;span class=&#34;number&#34;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; *ptr = arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;ptr[&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;] = &lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;; &lt;span class=&#34;comment&#34;&gt;// 通过指针ptr访问arr[2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;数组，指针，类型，函数定义问题&#34;&gt;&lt;a href=&#34;#数组，指针，类型，函数定义问题&#34; class=&#34;headerlink&#34; title=&#34;数组，指针，类型，函数定义问题&#34;&gt;&lt;/a&gt;数组，指针，类型，函数定义问题&lt;/h3&gt;&lt;p&gt;一个大小为10的数组，元素为指向整型的指针：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;	*a[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个指向大小为10，元素为整型的数组的指针：&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a)[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个函数指针，函数接受一个整型参数并返回一个整型&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a)(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个大小为10，元素是指向函数的指针的数组，这个函数接受整型参数并返回一个整型&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; (*a[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;])(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个指针，指向一个大小为10的数组，数组的元素是指向函数的指针，这个函数接受整型指针参数并返回一个整型指针&lt;/p&gt;
&lt;figure class=&#34;highlight c&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*) *(*a)[&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;](&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;*);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&#34;进程，线程与协程&#34;&gt;&lt;a href=&#34;#进程，线程与协程&#34; class=&#34;headerlink&#34; title=&#34;进程，线程与协程&#34;&gt;&lt;/a&gt;进程，线程与协程&lt;/h2&gt;&lt;h3 id=&#34;概念&#34;&gt;&lt;a href=&#34;#概念&#34; class=&#34;headerlink&#34; title=&#34;概念&#34;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;进程：进程是系统资源分配的基本单位，进程之间是相互独立的&lt;/li&gt;
&lt;li&gt;线程：线程属于进程，是系统调度运算的最小单位&lt;/li&gt;
&lt;li&gt;协程：属于轻量级的线程，由程序员手动控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区别&#34;&gt;&lt;a href=&#34;#区别&#34; class=&#34;headerlink&#34; title=&#34;区别&#34;&gt;&lt;/a&gt;区别&lt;/h3&gt;&lt;h4 id=&#34;进程与线程&#34;&gt;&lt;a href=&#34;#进程与线程&#34; class=&#34;headerlink&#34; title=&#34;进程与线程&#34;&gt;&lt;/a&gt;进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不同单位：进程是系统资源分配的基本单位，而线程是处理器进行运算调度的基本单位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源分配：进程直接占用系统资源，进程与进程之间占用的资源不同。线程占用一部分所属进程的资源，线程与线程之间可以共享资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相互切换：进程切换需要保存或者恢复之前的状态，成本较高。线程切换不需要较高的开销，因为它们共享资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通信方式：进程之间无法直接通信，需要使用IPC，如管道，消息队列，共享内存等。线程则通过互斥锁，信号量等方式通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;线程与协程&#34;&gt;&lt;a href=&#34;#线程与协程&#34; class=&#34;headerlink&#34; title=&#34;线程与协程&#34;&gt;&lt;/a&gt;线程与协程&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;一个线程可以有多个协程。&lt;/li&gt;
&lt;li&gt;大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。&lt;/li&gt;
&lt;li&gt;线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。&lt;/li&gt;
&lt;li&gt;协程并不是取代线程，而且抽象于线程之上。线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;MySQL&#34;&gt;&lt;a href=&#34;#MySQL&#34; class=&#34;headerlink&#34; title=&#34;MySQL&#34;&gt;&lt;/a&gt;MySQL&lt;/h2&gt;&lt;h3 id=&#34;ACID&#34;&gt;&lt;a href=&#34;#ACID&#34; class=&#34;headerlink&#34; title=&#34;ACID&#34;&gt;&lt;/a&gt;ACID&lt;/h3&gt;&lt;p&gt;事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、&lt;a href=&#34;https://www.zhihu.com/search?q=%E9%9A%94%E7%A6%BB%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;隔离性&lt;/a&gt;（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/search?q=%E5%8E%9F%E5%AD%90%E6%80%A7&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;原子性&lt;/a&gt;。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性。&lt;a href=&#34;https://www.zhihu.com/search?q=%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;事务执行&lt;/a&gt;的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。&lt;/p&gt;
&lt;p&gt;如果&lt;a href=&#34;https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;数据库系统&lt;/a&gt;运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入&lt;a href=&#34;https://www.zhihu.com/search?q=%E7%89%A9%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;物理数据库&lt;/a&gt;，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四个隔离等级&#34;&gt;&lt;a href=&#34;#四个隔离等级&#34; class=&#34;headerlink&#34; title=&#34;四个隔离等级&#34;&gt;&lt;/a&gt;四个隔离等级&lt;/h3&gt;&lt;p&gt;MySQL支持四个事务隔离级别，它们分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;读未提交（Read Uncommitted）&lt;/strong&gt;：在该隔离级别下，一个事务可以读取到另一个事务未提交的修改。这意味着事务之间没有隔离，可能会出现脏读（Dirty Read）、不可重复读（Non-Repeatable Read）和幻读（Phantom Read）等问题。&lt;ul&gt;
&lt;li&gt;脏读：读取未提交的数据&lt;/li&gt;
&lt;li&gt;不可重复读：同一事务的其他实例可能会在某实例commit后有新的commit，因此不可重复读&lt;/li&gt;
&lt;li&gt;幻读：简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过&lt;a href=&#34;https://www.zhihu.com/search?q=%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22422098523%22%7D&#34;&gt;多版本并发控制&lt;/a&gt;（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读已提交（Read Committed）&lt;/strong&gt;：在该隔离级别下，一个事务只能读取到其他事务已经提交的修改。这样可以避免脏读，但仍然可能发生不可重复读和幻读的问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重复读（Repeatable Read）&lt;/strong&gt;：在该隔离级别下，一个事务在同一个字段上的多次读取结果是一致的，即不可重复读问题得到解决。但是，可能会出现幻读问题，即事务在同一范围内多次查询时，结果集不一致。MVCC可以解决该问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;串行化（Serializable）&lt;/strong&gt;：在该隔离级别下，事务是串行执行的，可以避免脏读、不可重复读和幻读等问题。但是，串行化会对系统性能产生较大影响，因为它限制了并发性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些隔离级别可以在使用SQL语句中通过设置&lt;code&gt;SET TRANSACTION ISOLATION LEVEL&lt;/code&gt;来指定。例如：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;sqlCopy code&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SET TRANSACTION ISOLATION LEVEL READ COMMITTED;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;需要根据具体应用场景和要求选择合适的事务隔离级别，以平衡数据的一致性和性能需求。&lt;/p&gt;
&lt;h1 id=&#34;代码结果问题&#34;&gt;&lt;a href=&#34;#代码结果问题&#34; class=&#34;headerlink&#34; title=&#34;代码结果问题&#34;&gt;&lt;/a&gt;代码结果问题&lt;/h1&gt;</content>
        <category term="Code" />
        <updated>2023-10-24T03:24:44.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/</id>
        <title>Leetcode-2516-每种字符至少取 K 个</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/18/Leetcode-2516-%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E8%87%B3%E5%B0%91%E5%8F%96-K-%E4%B8%AA/"/>
        <content type="html">&lt;p&gt;hexo&lt;/p&gt;
&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个由字符 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;c&amp;#39;&lt;/code&gt; 组成的字符串 &lt;code&gt;s&lt;/code&gt; 和一个非负整数 &lt;code&gt;k&lt;/code&gt; 。每分钟，你可以选择取走 &lt;code&gt;s&lt;/code&gt; &lt;strong&gt;最左侧&lt;/strong&gt; 还是 &lt;strong&gt;最右侧&lt;/strong&gt; 的那个字符。&lt;/p&gt;
&lt;p&gt;你必须取走每种字符 &lt;strong&gt;至少&lt;/strong&gt; &lt;code&gt;k&lt;/code&gt; 个，返回需要的 &lt;strong&gt;最少&lt;/strong&gt; 分钟数；如果无法取到，则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s = &amp;quot;aabaaaacaabc&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从 s 的左侧取三个字符，现在共取到两个字符 &amp;#x27;a&amp;#x27; 、一个字符 &amp;#x27;b&amp;#x27; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从 s 的右侧取五个字符，现在共取到四个字符 &amp;#x27;a&amp;#x27; 、两个字符 &amp;#x27;b&amp;#x27; 和两个字符 &amp;#x27;c&amp;#x27; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;共需要 3 + 5 = 8 分钟。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;可以证明需要的最少分钟数是 8 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s = &amp;quot;a&amp;quot;, k = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：无法取到一个字符 &amp;#x27;b&amp;#x27; 或者 &amp;#x27;c&amp;#x27;，所以返回 -1 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由字母 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;b&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;c&amp;#39;&lt;/code&gt; 组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= s.length&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;主打一个逆向思维+双指针操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要从两边至少分别取k个a，b，c的字符，剩下的一个连续字符串所含的各字符一定不超过总数减去k个。我们要找最小的花费（分钟数），则要找最长的这个连续字符串，且该字符串需要满足上述条件。&lt;/p&gt;
&lt;p&gt;首先对每个字符的数量计数，若有一种字符的出现数量少于k，那么直接返回-1&lt;/p&gt;
&lt;p&gt;然后使用双指针法，遍历左指针的位置，使用右指针去扩大连续字符串的范围，直到满足条件。在左指针向右移动的过程中，&lt;strong&gt;右指针始终递增&lt;/strong&gt;，因此可以做到O(n)的时间复杂度，而不是O(n^2)去遍历两个指针的位置。&lt;strong&gt;注意特殊情况，即当右指针一步也没走出去，以及right当前所指位置并未计入有效字符串中。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;a href=&#34;#时间复杂度与空间复杂度&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;/a&gt;时间复杂度与空间复杂度&lt;/h1&gt;&lt;p&gt;时间复杂度：一次遍历，复杂度O(n)&lt;/p&gt;
&lt;p&gt;空间复杂度：双指针占用常数级空间，即O(1)&lt;/p&gt;
&lt;h1 id=&#34;代码实现&#34;&gt;&lt;a href=&#34;#代码实现&#34; class=&#34;headerlink&#34; title=&#34;代码实现&#34;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;takeCharacters&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, k: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        c = &amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;b&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;c&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; ch &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; s:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           c[ch] += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; e &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; c:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; c[e] &amp;lt; k:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;# print(c)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        d = &amp;#123;&lt;span class=&#34;string&#34;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;b&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;string&#34;&gt;&amp;#x27;c&amp;#x27;&lt;/span&gt;:&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        right = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        res = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; left &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s)):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;comment&#34;&gt;# print(d)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; right &amp;lt; left: &lt;span class=&#34;comment&#34;&gt;#若right甚至未踏出一步，从新的left开始&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                right = left&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; right &amp;lt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s) &lt;span class=&#34;keyword&#34;&gt;and&lt;/span&gt; d[s[right]] &amp;lt; c[s[right]] - k:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                d[s[right]] += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                right += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            res = &lt;span class=&#34;built_in&#34;&gt;max&lt;/span&gt;(res, right - left)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; left &amp;lt; right: &lt;span class=&#34;comment&#34;&gt;# 如果right踏出至少一步，因为left即将左移，那么从字典中减去left所指位置字符的出现数量一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                d[s[left]] -= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s) - res&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

</content>
        <category term="Code" />
        <updated>2023-10-18T15:31:57.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/</id>
        <title>LeetcodeWeekly-366-04:对数组执行操作使平方和最大</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/17/LeetcodeWeekly-366-04-%E5%AF%B9%E6%95%B0%E7%BB%84%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%B9%B3%E6%96%B9%E5%92%8C%E6%9C%80%E5%A4%A7/"/>
        <content type="html">&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个 &lt;strong&gt;正&lt;/strong&gt; 整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以对数组执行以下操作 &lt;strong&gt;任意次&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择两个互不相同的下标 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; ，&lt;strong&gt;同时&lt;/strong&gt; 将 &lt;code&gt;nums[i]&lt;/code&gt; 更新为 &lt;code&gt;(nums[i] AND nums[j])&lt;/code&gt; 且将 &lt;code&gt;nums[j]&lt;/code&gt; 更新为 &lt;code&gt;(nums[i] OR nums[j])&lt;/code&gt; ，&lt;code&gt;OR&lt;/code&gt; 表示按位 &lt;strong&gt;或&lt;/strong&gt; 运算，&lt;code&gt;AND&lt;/code&gt; 表示按位 &lt;strong&gt;与&lt;/strong&gt; 运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你需要从最终的数组里选择 &lt;code&gt;k&lt;/code&gt; 个元素，并计算它们的 &lt;strong&gt;平方&lt;/strong&gt; 之和。&lt;/p&gt;
&lt;p&gt;请你返回你可以得到的 &lt;strong&gt;最大&lt;/strong&gt; 平方和。&lt;/p&gt;
&lt;p&gt;由于答案可能会很大，将答案对 &lt;code&gt;109 + 7&lt;/code&gt; &lt;strong&gt;取余&lt;/strong&gt; 后返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [2,6,5,8], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：261&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：我们可以对数组执行以下操作：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;261 是可以得到的最大结果。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [4,5,4,7], k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：90&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：不需要执行任何操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;90 是可以得到的最大结果。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums[i] &amp;lt;= 109&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a&#34;&gt;解法思路来自 @灵茶山艾府 大佬&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于无论是AND还是OR，都不会改变两个数都是1或者0的结果，因此&lt;strong&gt;题中操作等价于交换两数的1和0，其中OR操作后的数会更大，而AND操作后的数会更小，并且增大和减小的值相等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于如果把一个数平均分配给两数的平方和一定小于一个数本身的平方，我们的目的是要将尽可能多的1转移到一个数上，并执行k次这样的操作。&lt;/p&gt;
&lt;p&gt;先遍历整个nums，找出每一位上有多少个1，最多30位（10^9小于2^30），存储在cnt里。之后遍历cnt，只要cnt每一位上的数还不为0，就使临时变量sum加上2^i，cnt对应位减1，遍历结束后加在最终的res里。执行k次以上操作，返回res。&lt;/p&gt;
&lt;h1 id=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;a href=&#34;#时间复杂度与空间复杂度&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度与空间复杂度&#34;&gt;&lt;/a&gt;时间复杂度与空间复杂度&lt;/h1&gt;&lt;p&gt;时间复杂度O(n)，空间复杂度O(1)&lt;/p&gt;
&lt;h1 id=&#34;代码实现&#34;&gt;&lt;a href=&#34;#代码实现&#34; class=&#34;headerlink&#34; title=&#34;代码实现&#34;&gt;&lt;/a&gt;代码实现&lt;/h1&gt;&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;maxSum&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, nums: &lt;span class=&#34;type&#34;&gt;List&lt;/span&gt;[&lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;], k: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        cnt = [&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; num &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; nums:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (num != &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                cnt[i] += num % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                i += &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                num &amp;gt;&amp;gt;= &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        res = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; _ &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(k):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            x = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;30&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                t = cnt[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; t:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    x += &lt;span class=&#34;built_in&#34;&gt;pow&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, i)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    cnt[i] = t - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            res += x * x&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; res % (&lt;span class=&#34;built_in&#34;&gt;pow&lt;/span&gt;(&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;9&lt;/span&gt;) + &lt;span class=&#34;number&#34;&gt;7&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

</content>
        <category term="Code" />
        <updated>2023-10-17T13:04:07.000Z</updated>
    </entry>
    <entry>
        <id>https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/</id>
        <title>LeetcodeWeekly-366-03:执行操作使两个字符串相等</title>
        <link rel="alternate" href="https://paperwings2019.github.io/2023/10/15/LeetcodeWeekly-366-03-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/"/>
        <content type="html">&lt;h1 id=&#34;题目描述&#34;&gt;&lt;a href=&#34;#题目描述&#34; class=&#34;headerlink&#34; title=&#34;题目描述&#34;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的二进制字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; ，两个字符串的长度都是 &lt;code&gt;n&lt;/code&gt; ，再给你一个正整数 &lt;code&gt;x&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;你可以对字符串 &lt;code&gt;s1&lt;/code&gt; 执行以下操作 &lt;strong&gt;任意次&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择两个下标 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; ，将 &lt;code&gt;s1[i]&lt;/code&gt; 和 &lt;code&gt;s1[j]&lt;/code&gt; 都反转，操作的代价为 &lt;code&gt;x&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;选择满足 &lt;code&gt;i &amp;lt; n - 1&lt;/code&gt; 的下标 &lt;code&gt;i&lt;/code&gt; ，反转 &lt;code&gt;s1[i]&lt;/code&gt; 和 &lt;code&gt;s1[i + 1]&lt;/code&gt; ，操作的代价为 &lt;code&gt;1&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你返回使字符串 &lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 相等的 &lt;strong&gt;最小&lt;/strong&gt; 操作代价之和，如果无法让二者相等，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ，反转字符的意思是将 &lt;code&gt;0&lt;/code&gt; 变成 &lt;code&gt;1&lt;/code&gt; ，或者 &lt;code&gt;1&lt;/code&gt; 变成 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;1100011000&amp;quot;, s2 = &amp;quot;0101001010&amp;quot;, x = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：我们可以执行以下操作：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 3 执行第二个操作。结果字符串是 s1 = &amp;quot;1101111000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 4 执行第二个操作。结果字符串是 s1 = &amp;quot;1101001000&amp;quot; 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = &amp;quot;0101001010&amp;quot; = s2 。&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;总代价是 1 + 1 + 2 = 4 。这是最小代价和。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：s1 = &amp;quot;10110&amp;quot;, s2 = &amp;quot;00011&amp;quot;, x = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：-1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：无法使两个字符串相等。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == s1.length == s2.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n, x &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 只包含字符 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解题思路&#34;&gt;&lt;a href=&#34;#解题思路&#34; class=&#34;headerlink&#34; title=&#34;解题思路&#34;&gt;&lt;/a&gt;解题思路&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;u&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1e84y117R9/?vd_source=ea0f2733af6b9f96a1a2ad6af5f1343a&#34;&gt;解法思路来自 @灵茶山艾府 大佬&lt;/a&gt;&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;解法一：O-n-2-时间动态规划&#34;&gt;&lt;a href=&#34;#解法一：O-n-2-时间动态规划&#34; class=&#34;headerlink&#34; title=&#34;解法一：O(n^2)时间动态规划&#34;&gt;&lt;/a&gt;解法一：O(n^2)时间动态规划&lt;/h2&gt;&lt;h3 id=&#34;如何直接判断能否使两个字符串相等？&#34;&gt;&lt;a href=&#34;#如何直接判断能否使两个字符串相等？&#34; class=&#34;headerlink&#34; title=&#34;如何直接判断能否使两个字符串相等？&#34;&gt;&lt;/a&gt;如何直接判断能否使两个字符串相等？&lt;/h3&gt;&lt;p&gt;主要看s1（或者s2也可以）中&lt;strong&gt;“1”的数量的奇偶性是否与s2（或者s1）中“1”的数量的奇偶性&lt;/strong&gt;相同。原因是，第一种操作与第二种操作都不会改变“1”的数量的奇偶性。第一种操作和第二种操作同时翻转两个位置，要么反转一个1一个0（奇偶性不变），要么反转两个1或者两个0（“1”的数量+2或-2，奇偶性仍不变）。因此若s1和s2中“1”的数量不相同，可以直接返回-1.&lt;/p&gt;
&lt;h3 id=&#34;DP数组的意义，递推公式，初始化&#34;&gt;&lt;a href=&#34;#DP数组的意义，递推公式，初始化&#34; class=&#34;headerlink&#34; title=&#34;DP数组的意义，递推公式，初始化&#34;&gt;&lt;/a&gt;DP数组的意义，递推公式，初始化&lt;/h3&gt;&lt;p&gt;三个参数：dp(i, j, preRev)，代表&lt;strong&gt;在处理前i个位置后，以及j个剩下的免费翻转机会，以及根据preRev的真假&lt;/strong&gt;（前一个位置是否选择第二种方法进行翻转）的状态下，最小的花费。这是因为，如果在处理先前的字符串时选择了第一种方法，相当于我们在处理之后的字符串时获得了免费的翻转机会。如果前一个位置选择了第二种操作，那么本位需要当作已经被翻转（即如果本来s1[2]&amp;#x3D;&amp;#x3D;’1’，但s1[1]使用了第二种操作使得s1[1] &amp;#x3D;&amp;#x3D; s2[1]，那么s1[2]应该被当做0来处理）。&lt;/p&gt;
&lt;p&gt;与一般的使用迭代的方法遍历dp数组不同，这里使用递归+cache的方法来遍历。假如(s1[i] &amp;#x3D;&amp;#x3D; s2[i]) &amp;#x3D;&amp;#x3D; &lt;strong&gt;not preRev&lt;/strong&gt;，那么dp(i, j, preRev) &amp;#x3D; dp(i-1, j, False)。 假如不同，首先分别计算第一种操作和第二种操作后的花费，取最小值。即dp(i, j, preRev) &amp;#x3D; min( dp(i-1, j+1, False) + x, dp(i-1, j, True) + 1 )。之后，假如j不为0，继续计算免费翻转后的花费，即dp(i, j, preRev) &amp;#x3D; min(dp(i, j, preRev), dp(i-1, j-1, False))，注意此处等号右边的dp(i, j, preRev)已经是第一种和第二种操作取最小值后的值。&lt;/p&gt;
&lt;p&gt;递归在i&amp;#x3D;&amp;#x3D;0时停止，这时假如j不为0，或者preRev不为假，则返回无穷大，保证该分支不会被选入最终结果。否则，返回0，即s1和s2都为空时，不需要操作。在主函数中，直接返回dp(len(s1), 0, False)的结果。&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析&#34;&gt;&lt;a href=&#34;#时间复杂度和空间复杂度分析&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度和空间复杂度分析&#34;&gt;&lt;/a&gt;时间复杂度和空间复杂度分析&lt;/h3&gt;&lt;p&gt;计算思路：状态数*单个状态下的计算复杂度。因为i和j分别可以最多可以取到len(s1)，preRev的状态集有限，且计算单个状态的时间复杂度是O(1) ，则总体的时间复杂度为O(n^2)。同理，空间复杂度也为O(n^2)。&lt;/p&gt;
&lt;h3 id=&#34;Python代码实现&#34;&gt;&lt;a href=&#34;#Python代码实现&#34; class=&#34;headerlink&#34; title=&#34;Python代码实现&#34;&gt;&lt;/a&gt;Python代码实现&lt;/h3&gt;&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (s1.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt; != s2.count(&lt;span class=&#34;string&#34;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;        @cache&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;dfs&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;i, j, preRev&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; i == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j == &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; inf&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; ((s1[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;] == s2[i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;]) == (&lt;span class=&#34;keyword&#34;&gt;not&lt;/span&gt; preRev)):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(i-&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;) + x, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j, &lt;span class=&#34;literal&#34;&gt;True&lt;/span&gt;) + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; j:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                t = &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(t, dfs(i - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, j - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; t&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; dfs(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1), &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;literal&#34;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;h2 id=&#34;解法二：O-n-时间动态规划&#34;&gt;&lt;a href=&#34;#解法二：O-n-时间动态规划&#34; class=&#34;headerlink&#34; title=&#34;解法二：O(n)时间动态规划&#34;&gt;&lt;/a&gt;解法二：O(n)时间动态规划&lt;/h2&gt;&lt;p&gt;单次遍历s1，记录下与s2每个位置上不同的下标，并存储在一个新数组p中。&lt;/p&gt;
&lt;h3 id=&#34;如何直接判断能否使两个字符串相等？-1&#34;&gt;&lt;a href=&#34;#如何直接判断能否使两个字符串相等？-1&#34; class=&#34;headerlink&#34; title=&#34;如何直接判断能否使两个字符串相等？&#34;&gt;&lt;/a&gt;如何直接判断能否使两个字符串相等？&lt;/h3&gt;&lt;p&gt;两种操作每次都需要正好对两个数操作，则假如p的长度为奇数，那么可以直接返回-1。&lt;/p&gt;
&lt;h3 id=&#34;动态规划意义及递推公式，初始化&#34;&gt;&lt;a href=&#34;#动态规划意义及递推公式，初始化&#34; class=&#34;headerlink&#34; title=&#34;动态规划意义及递推公式，初始化&#34;&gt;&lt;/a&gt;动态规划意义及递推公式，初始化&lt;/h3&gt;&lt;p&gt;设f(i)为处理数组p前i个元素所需要花费的时间&lt;/p&gt;
&lt;p&gt;来看如何处理当前位置为i的元素：对于第一种操作，花费可看作是x&amp;#x2F;2，即f(i) &amp;#x3D; f(i-1) + x&amp;#x2F;2。对于第二种操作，需要看上一个位置与该位置的“距离”，连续翻转之间的数，即f(i) &amp;#x3D; f(i-2) + p[i-1] - p[i]。&lt;/p&gt;
&lt;p&gt;因此f(0)&amp;#x3D;0,f(1)&amp;#x3D;x&amp;#x2F;2&lt;/p&gt;
&lt;h3 id=&#34;时间复杂度和空间复杂度分析-1&#34;&gt;&lt;a href=&#34;#时间复杂度和空间复杂度分析-1&#34; class=&#34;headerlink&#34; title=&#34;时间复杂度和空间复杂度分析&#34;&gt;&lt;/a&gt;时间复杂度和空间复杂度分析&lt;/h3&gt;&lt;p&gt;对于每个f(i)，我们只需要知道f(i-1)和f(i-2)，因此我们需要维护两个状态（滚动数组），最后返回其中第一个状态。时间复杂度O(n)，空间复杂度O(n)。&lt;/p&gt;
&lt;h3 id=&#34;Python代码实现-1&#34;&gt;&lt;a href=&#34;#Python代码实现-1&#34; class=&#34;headerlink&#34; title=&#34;Python代码实现&#34;&gt;&lt;/a&gt;Python代码实现&lt;/h3&gt;&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;minOperations&lt;/span&gt;(&lt;span class=&#34;params&#34;&gt;self, s1: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, s2: &lt;span class=&#34;built_in&#34;&gt;str&lt;/span&gt;, x: &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;&lt;/span&gt;) -&amp;gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1 == s2: &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        p = [i &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;range&lt;/span&gt;(&lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(s1)) &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; s1[i] != s2[i]]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;len&lt;/span&gt;(p) % &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        f0, f1 = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; i, j &lt;span class=&#34;keyword&#34;&gt;in&lt;/span&gt; pairwise(p):&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            f0, f1 = f1, &lt;span class=&#34;built_in&#34;&gt;min&lt;/span&gt;(f1 + x / &lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;, f0 + j - i)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;built_in&#34;&gt;int&lt;/span&gt;(f1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&#34;思考题&#34;&gt;&lt;a href=&#34;#思考题&#34; class=&#34;headerlink&#34; title=&#34;思考题&#34;&gt;&lt;/a&gt;思考题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;如果第一种操作限制|i-j|&amp;gt;&amp;#x3D;k呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以多维护一个整数参数t，记录下一个可以进行免费翻转的下标位置，即如果使用第一种操作，那么t更新为i+k。在判断是否能免费翻转时，除了j还需要看当前i是否大于等于t，如果都满足的话才能免费翻转。&lt;/p&gt;
</content>
        <category term="Code" />
        <updated>2023-10-15T05:50:21.000Z</updated>
    </entry>
</feed>
