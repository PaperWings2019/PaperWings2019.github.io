{
    "version": "https://jsonfeed.org/version/1",
    "title": "PaperWings Blog • All posts by \"daily\" tag",
    "description": "",
    "home_page_url": "https://paperwings2019.github.io",
    "items": [
        {
            "id": "https://paperwings2019.github.io/2024/06/02/Unix-Socket-%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "url": "https://paperwings2019.github.io/2024/06/02/Unix-Socket-%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
            "title": "Unix Socket 编程笔记",
            "date_published": "2024-06-02T03:50:56.000Z",
            "content_html": "<p>最近工作上用到了 Unix Socket 编程，学到了很多新东西，特地在此记录一下！</p>\n<h1 id=\"概念介绍\"><a class=\"markdownIt-Anchor\" href=\"#概念介绍\">#</a> 概念介绍</h1>\n<p>首先 Socket 是两个进程之间通信最底层的结构，所有通信协议，如 TCP 和 UDP 都基于 Socket 之上。这里的两个进程可以是一台主机上的不同进程，也可以是两台主机上，也就是客户端和服务器之间的两个进程。两个进程分别叫做客户端和服务端，他们初始化 Socket 的流程是不一样的，当然功能也不一样。客户端可以向服务端发送消息，而服务端接收到消息后根据客户端的需要返回有用的信息。接下来来看看在编程中如何做到这些吧。</p>\n<h1 id=\"服务端\"><a class=\"markdownIt-Anchor\" href=\"#服务端\">#</a> 服务端</h1>\n<p>首先我们需要创建一个服务器端的 socket，使用 socket 函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"type\">int</span> domain, <span class=\"type\">int</span> type, <span class=\"type\">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>让我们一行一行解释：</p>\n<p>首先要保证引入了 <code>socket.h</code>  头文件，才能调用提供的接口。socket 函数是客户端以及服务端都需要用到的方法，作用是创建一个套接字，其类型为整型，创建的套接字是一个文件描述符，唯一代表了服务器，并在之后的操作中会用到。下面依次介绍各个参数：</p>\n<ul>\n<li><code>domain</code> ：说明了该套接字将要作用的域，包括 Unix 域（两个进程都在同一个主机上），以及网络域（两个进程在两个不同的主机上）。一般使用宏来指定，分别是 <code>AF_UNIX</code>  和 <code>AF_INET</code> 。</li>\n<li><code>type</code> ：指定如何传递数据包。有两种最常见的类型，即 <code>SOCK_STREAM</code>  和 <code>SOCK_DATAGRAM</code> ，分别代表以流形式传输数据以及以数据报的形式传输数据。以流形式传输的信息保证了可靠以及有序的特点，而以数据报传输的数据是无序的，不可靠的。对于要精确地传递某种信息，例如账号、密码等，必须要选择流形式的数据。通信协议 TCP 和 UDP 就分别对应这两个类型。</li>\n<li><code>protocol</code> ：为套接字指定一种协议，一般使用默认值 <code>0</code>  即可</li>\n</ul>\n<p>下面是一个例子，使用了 <code>socket</code>  函数创建了一个基于 UNIX，以流形式传输数据，且协议为默认的套接字：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> server_socket = <span class=\"built_in\">socket</span>(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// failed to create a socket</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (server_socket &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正常创建出的套接字总是大于 0，假如其值为 - 1，那么说明创建失败，此时直接退出程序。</p>\n<p>接下来，我们需要 “绑定” 这个新创建的套接字到一个 “地址” 上。为什么要绑定地址？很简单，假如要和另外一个进程进行通信，你必须知道对方的地址呀！现在我们要做的，就是表明服务器的地址是什么。对于 UNIX 套接字来说，它是一个指向一个特殊文件的路径，这个特殊文件是一个端点，通俗地讲就是两个进程间的 “碰头点”。（对于网络套接字来说，这个地址就是我们熟知的 IP 地址和端口号。）</p>\n<p>我们使用 bind 函数来做到以上所说：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> sockaddr *addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>同样的，我们还是解释一下上述参数：</p>\n<ul>\n<li><code>sockfd</code> ：即我们用 <code>socket</code>  函数所创建的套接字，它是一个文件描述符</li>\n<li><code>addr</code> ：是一个 <code>sockaddr</code>  的结构体，里面的成员定义了地址等信息</li>\n<li><code>addrlen</code> ：顾名思义，是以上结构体的所占用的大小（注意不是地址字符串的长度）</li>\n</ul>\n<p>对于不同的套接字（AF_UNIX or AF_INET）这里要用到的 sockaddr 的结构体是不一样的，并且在作为参数时需要重新 cast。下面是一个例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/un.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_un</span> server_address;</span><br><span class=\"line\">server_address.sun_family = AF_UNIX;</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(server_address.sun_path, <span class=\"string\">&quot;/tmp/socket_server&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(server_socket, <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"keyword\">struct</span> sockaddr *&gt;(&amp;server_address), <span class=\"built_in\">sizeof</span>(server_address)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先定义了一个基于 UNIX 的地址结构体 <code>sockaddr_un</code> ，其中的成员 <code>sun_family</code>  再次确定这是基于 UNIX 编程的结构体（网络编程有不同的结构体 <code>sockaddr_in</code> ），成员 <code>sun_path</code>  指定了一个地址，以字符数组来表示。在调用 bind 函数时，我们将 <code>server_address</code>  重新 cast 为正确的结构体，这么做是为了欺骗编译器。bind 函数的返回值告诉我们绑定操作是否成功，若小于 0 则代表绑定失败。</p>\n<p>下一步是使用 <code>listen</code>  函数使得套接字进入监听状态：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"type\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>参数解释：</p>\n<ul>\n<li>sockfd：还是我们创建的套接字</li>\n<li>backlog：指定了最多能够处理多少个客户端</li>\n</ul>\n<p>当一个套接字被置于监听状态后，内核会维护两个队列：</p>\n<ul>\n<li><strong>未完成连接队列</strong>：包含那些已经完成了三次握手但还没有被应用层接受的连接。</li>\n<li><strong>已完成连接队列</strong>：包含那些已被应用层调用 <code>accept</code>  函数处理的连接。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(server_socket, <span class=\"number\">20</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后一步，那就是去接受来自客户端的连接啦～我们使用 accept 函数去处理这件事，注意在有客户端连接之前，这个函数会始终阻塞。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"type\">int</span> sockfd, <span class=\"keyword\">struct</span> sockaddr* addr, <span class=\"type\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>这是非常关键的一步，我们展开参数讲讲：</p>\n<ul>\n<li><code>sockfd</code> ：仍然是我们之前创建的套接字</li>\n<li><code>addr</code> ：之前已经定义过地址，为什么这里还要定义一个呢？这是因为这个地址是为客户端准备的，也就是说这个地址即将存放与服务端连接的地址。</li>\n<li>addrlen：还是和之前一样，表示结构体的长度</li>\n</ul>\n<p>参数看起来平平无奇，但是 accept 即将返回的是一个新的 socket，后续的通信将会用到这个新的 socket，而不是之前一开始创建的 server_socket。如果我们不关心客户端的地址，直接拿 <code>nullptr</code>  代替即可！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> comm_socket = <span class=\"built_in\">accept</span>(server_socket, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (comm_socket &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，现在连接建立了，是时候接收和发送信息了！我们分别使用 <code>recv</code>  和 <code>send</code>  函数来接收和发送信息。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> read_size = <span class=\"built_in\">recv</span>(comm_socket, buffer, <span class=\"built_in\">sizeof</span>(buffer), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (read_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">buffer[read_size] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> write_size = <span class=\"built_in\">send</span>(comm_socket, buffer, read_size, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (write_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不免看出，这些函数都有着浓浓的 C 语言味。不论是接收还是发送消息，我们需要提前创建一个字符数组，其大小代表一次最大可以接受多长的信息。再次注意，我们使用了 <code>accept</code>  函数返回的套接字，而不是一开始的套接字。这里，我们将接收到的消息原封不动地发送回给客户端。</p>\n<p>整体代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/un.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> server_socket = <span class=\"built_in\">socket</span>(AF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// failed to create a socket</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (server_socket &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">sockaddr_un</span> server_address;</span><br><span class=\"line\">    server_address.sun_family = AF_UNIX;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(server_address.sun_path, <span class=\"string\">&quot;/tmp/socket_server&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">bind</span>(server_socket, <span class=\"built_in\">reinterpret_cast</span>&lt;<span class=\"keyword\">struct</span> sockaddr *&gt;(&amp;server_address), <span class=\"built_in\">sizeof</span>(server_address)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">listen</span>(server_socket, <span class=\"number\">20</span>) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> comm_socket = <span class=\"built_in\">accept</span>(server_socket, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comm_socket &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> read_size = <span class=\"built_in\">recv</span>(comm_socket, buffer, <span class=\"built_in\">sizeof</span>(buffer), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (read_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buffer[read_size] = <span class=\"string\">&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> write_size = <span class=\"built_in\">send</span>(comm_socket, buffer, read_size, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write_size &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(comm_socket);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "Daily"
            ]
        },
        {
            "id": "https://paperwings2019.github.io/2023/10/15/My%20first%20post/",
            "url": "https://paperwings2019.github.io/2023/10/15/My%20first%20post/",
            "title": "My first Post",
            "date_published": "2023-10-15T02:22:03.000Z",
            "content_html": "<p>Hello World</p>\n",
            "tags": [
                "Daily"
            ]
        }
    ]
}